# py_simple_ttk 0.1.0<a name="mark0"></a>

***Themes don't have to be hard.***

- [About](#mark1)
- [Requirements](#mark2)
- [Configuring ini.json](#mark3)
- [SuperLib.widgets](#mark4)
	- [Core Functions](#mark5)
		- [bbox_to_width_and_height](#mark6)
		- [center_window](#mark7)
		- [check_in_bounds](#mark8)
		- [complex_widget_search](#mark9)
		- [copy_to_user_clipboard](#mark10)
		- [create_round_rectangle](#mark11)
		- [default_pack](#mark12)
		- [default_separator](#mark13)
		- [default_vertical_pack](#mark14)
		- [default_vertical_separator](#mark15)
		- [enable_notebook_movement](#mark16)
		- [focus_next](#mark17)
		- [force_aspect](#mark18)
		- [get_asset](#mark19)
		- [get_bundled_themes_list](#mark20)
		- [get_generated_font_images_lookup](#mark21)
		- [get_local_appdata_folder](#mark22)
		- [get_themes_folder](#mark23)
		- [open_link](#mark24)
		- [recursive_widget_search](#mark25)
		- [run_cl](#mark26)
	- [Core Widgets](#mark27)
		- [MultiWidgetMixin](#mark28)
		- [SuperWidgetMixin](#mark29)
	- [Tabs](#mark30)
		- [Tab](#mark31)
		- [LauncherTab](#mark32)
		- [BrowserLauncherTab](#mark33)
		- [CommandLauncherTab](#mark34)
		- [ConsoleTab](#mark35)
		- [TableTab](#mark36)
		- [TreeTableTab](#mark37)
	- [Canvas Widgets](#mark38)
		- [ResizableCanvas](#mark39)
		- [ScrolledCanvas](#mark40)
		- [TiledCanvas](#mark41)
		- [ExampleTile](#mark42)
	- [Checkbutton Widgets](#mark43)
		- [LabeledCheckbutton](#mark44)
		- [LabeledMultiCheckbutton](#mark45)
	- [Combobox Widgets](#mark46)
		- [LabeledCombobox](#mark47)
		- [LabeledMultiCombobox](#mark48)
	- [Console Widgets](#mark49)
		- [ConsoleWidget](#mark50)
	- [Entry Widgets](#mark51)
		- [ScrolledEntry](#mark52)
		- [LabeledEntry](#mark53)
		- [LabeledMultiEntry](#mark54)
		- [LabeledButtonEntry](#mark55)
		- [LabeledMultiButtonEntry](#mark56)
		- [PasswordEntry](#mark57)
	- [KeyPad Widgets](#mark58)
		- [KeypadButton](#mark59)
		- [BaseKeypad](#mark60)
		- [DialerKeypad](#mark61)
	- [ListBox Widgets](#mark62)
		- [ScrolledListBox](#mark63)
		- [Table](#mark64)
	- [OptionMenu Widgets](#mark65)
		- [LabeledOptionMenu](#mark66)
		- [LabeledMultiOptionMenu](#mark67)
	- [ProgressBar Widgets](#mark68)
		- [LabeledProgressbar](#mark69)
		- [LabeledMultiProgressbar](#mark70)
	- [Radiobutton Widgets](#mark71)
		- [LabeledRadiobutton](#mark72)
		- [LabeledMultiRadiobutton](#mark73)
	- [Scale Widgets](#mark74)
		- [LabeledScale](#mark75)
		- [LabeledMultiScale](#mark76)
	- [Text Widgets](#mark77)
		- [ScrolledText](#mark78)
		- [CopyBox](#mark79)
	- [Toplevel Widgets](#mark80)
		- [FocusedToplevel](#mark81)
		- [NoticeWindow](#mark82)
		- [YesNoCancelWindow](#mark83)
		- [PromptWindow](#mark84)
		- [PasswordWindow](#mark85)
		- [ListWindow](#mark86)
	- [Misc Widgets](#mark87)
		- [ToolTip](#mark88)
		- [EasySizegrip](#mark89)
- [SuperLib.utils](#mark90)
	- [Utils](#mark91)
		- [check_if_module_installed](#mark92)
		- [check_string_contains](#mark93)
		- [dummy_function](#mark94)
		- [get_friendly_time](#mark95)
		- [get_installed_packages](#mark96)
		- [get_unix_timestamp](#mark97)
		- [get_unix_timestring](#mark98)
		- [get_user_home_folder](#mark99)
		- [open_folder_in_explorer](#mark100)
		- [sort_dict_by_keys](#mark101)
		- [timer_decorator](#mark102)
	- [File Generators](#mark103)
		- [HTML_Generator](#mark104)
		- [TXT_Generator](#mark105)
		- [MD_Generator](#mark106)
	- [History Mixin](#mark107)
		- [HistoryMixin](#mark108)
	- [Color Functions](#mark109)
		- [reduce](#mark110)
		- [rgb_to_hex](#mark111)
		- [rgba_to_hex](#mark112)
		- [hex_to_rgb](#mark113)
		- [hex_to_rgba](#mark114)
		- [get_gradient](#mark115)
		- [rgb_to_scalar](#mark116)
		- [scalar_to_rgb](#mark117)
		- [linear_gradient](#mark118)
		- [get_rainbow](#mark119)
- [SuperLib.mega_widgets](#mark120)
	- [Notes MegaWidget](#mark121)
		- [NotesTab](#mark122)
	- [Conversation MegaWidget](#mark123)
		- [ConversationsTab](#mark124)
	- [Profile Management](#mark125)
		- [ProfilesSystem](#mark126)
		- [UserProfile](#mark127)
		- [get_profiles_folder](#mark128)
		- [get_profiles_list](#mark129)
- [Changelog](#mark130)
	- [0.1.0](#mark131)

---

# About<a name="mark1"></a>[^](#mark0)

py_simple_ttk exists because I got tired of rewriting the same code over and over for simple projects. The goal is to provide a variety of meta widgets with consistent get/set/enable/disable/destroy methods and mega-widgets that make ttk development easier and faster. Features include built-in theme support, a score of labeled and multi-widgets, tools for easy form building, a sample application demonstrating many of py_simple_ttk's features, a configuration file system, and much more. ![Lines of code](https://img.shields.io/tokei/lines/github/AndrewSpangler/py_simple_ttk)

# Requirements<a name="mark2"></a>[^](#mark0)



# Configuring ini.json<a name="mark3"></a>[^](#mark0)

```python
+--------------------+-------------------------------------------+
|        Key         |                   Value                   |
+--------------------+-------------------------------------------+
| application        | Application Name (String)                 |
| version            | Application Version (String)              |
| icon               | Application Icon Path (String)            |
| width              | Startup Window Width (Int)                |
| height             | Startup Window Height (Int)               |
| minwidth           | Window Minimum Width (Int)                |
| minheight          | Window Minimum Height (Int)               |
| scaling            | Window Scaling (Float)                    |
| scale_minsize      | Scale application Minimum Size (Boolean)  |
| scale_startsize    | Scale application Start Size (Boolean)    |
| resizable_width    | Enable Window Width Resizing (Boolean)    |
| resizable_height   | Enable Window Height Resizing (Boolean)   |
| start_maximized    | Start Window Maximized (Boolean)          |
| enable_maximized   | Enable Window Maximized (Boolean)         |
| start_fullscreen   | Start Window in Fullscreen mode (Boolean) |
| enable_fullscreen  | Enable Window Fullscreen option (Boolean) |
| enable_themes_menu | Enable Themes Dropdown (Boolean)          |
| movable_tabs       | Enable Moveable Notebook Tabs (Boolean)   |
| enable_users       | Enable a User Profiles System             |
+--------------------+-------------------------------------------+
```
# SuperLib.widgets<a name="mark4"></a>[^](#mark0)

## Core Functions<a name="mark5"></a>[^](#mark4)

### py_simple_ttk.widgets.WidgetsCore.bbox_to_width_and_height<a name="mark6"></a>[^](#mark5)
> **Takes a bbox and converts it to a width and height tuple.**
> 
> ```python
def bbox_to_width_and_height(bbox: tuple):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.center_window<a name="mark7"></a>[^](#mark5)
> **Centers spawn window on main window. Call win.update_idletasks() on either window before calling this if said window is not yet shown.**
> 
> ```python
def center_window(main_window: tkinter.Tk, spawn_window: tkinter.Toplevel):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.check_in_bounds<a name="mark8"></a>[^](#mark5)
> **Checks if a position is within a given bounds. Pos is generally a mouse event position tuple, bounds is generally a canvas.bbox(), but a (left, top, right, bottom) tuple will work too.**
> 
> ```python
def check_in_bounds(pos: tuple, bounds: tuple):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.complex_widget_search<a name="mark9"></a>[^](#mark5)
> **A more robust version of the widget search with lists for multiple widget types found in one go**
> 
> ```python
def complex_widget_search(node_widget, widget_types_to_find: list, found_lists={}):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.copy_to_user_clipboard<a name="mark10"></a>[^](#mark5)
> **Copies a string to the user's clipboard.**
> 
> ```python
def copy_to_user_clipboard(widget, value):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.create_round_rectangle<a name="mark11"></a>[^](#mark5)
> **Draws a rounded rectangle of a given radius on a tk.canvas**
> 
> ```python
def create_round_rectangle(canvas, x1, y1, x2, y2, r=20, fill='', outline='#000000', **kwargs):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.default_pack<a name="mark12"></a>[^](#mark5)
> **Apply a consistent descending packing method.**
> 
> ```python
def default_pack(widget, bottom: bool = False, padx=5):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.default_separator<a name="mark13"></a>[^](#mark5)
> **Apply a consistent horizontal separator.**
> 
> ```python
def default_separator(f: tkinter.ttk.Frame, padx: int = 35, pady=(10, 5)):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.default_vertical_pack<a name="mark14"></a>[^](#mark5)
> **Apply a consistent packing method to vertically packed widgets.**
> 
> ```python
def default_vertical_pack(widget, expand: bool = False, fill: str = 'both', padx: int = 0):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.default_vertical_separator<a name="mark15"></a>[^](#mark5)
> **Apply a consistent vertical separator.**
> 
> ```python
def default_vertical_separator(frame: tkinter.ttk.Frame, pady: int = 15, padx: int = 10):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.enable_notebook_movement<a name="mark16"></a>[^](#mark5)
> **Copyright CJB 2010-07-31: https://wiki.tcl-lang.org/page/Drag+and+Drop+Notebook+Tabs Enables Tab dragging in subsequently created notebooks. Only run this function once.**
> 
> ```python
def enable_notebook_movement(app):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.focus_next<a name="mark17"></a>[^](#mark5)
> **Forces focus to the widget after the one that triggered the event**
> 
> ```python
def focus_next(event):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.force_aspect<a name="mark18"></a>[^](#mark5)
> **Forces an inner frame to maintain an aspect ratio regardless of the outer frame's size**
> 
> ```python
def force_aspect(inner_frame: tkinter.ttk.Frame, outer_frame: tkinter.ttk.Frame, ratio=1.7777777777777777):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.get_asset<a name="mark19"></a>[^](#mark5)
> **Gets an asset from the included assets folder by relative path**
> 
> ```python
def get_asset(path, folder='C:\\Users\\arcti\\github\\SuperTTK\\py_simple_ttk\\./assets'):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.get_bundled_themes_list<a name="mark20"></a>[^](#mark5)
> **None**
> 
> ```python
def get_bundled_themes_list(verbose=False):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.get_generated_font_images_lookup<a name="mark21"></a>[^](#mark5)
> **Makes a lookup for the pre-generated open-sans font monograms that ship with py_simple_ttk.**
> 
> ```python
def get_generated_font_images_lookup(path=None):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.get_local_appdata_folder<a name="mark22"></a>[^](#mark5)
> **Opens user's Windows home folder. Only works on Windows for obvious reasons.**
> 
> ```python
def get_local_appdata_folder():
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.get_themes_folder<a name="mark23"></a>[^](#mark5)
> **Gets the absolute path to the included themes folder**
> 
> ```python
def get_themes_folder():
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.open_link<a name="mark24"></a>[^](#mark5)
> **Opens a link in the user's default web browser. `Returns None`**
> 
> ```python
def open_link(link: str):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.recursive_widget_search<a name="mark25"></a>[^](#mark5)
> **Adds widgets of a given type to a list as it travels up, away from the root of a widget tree. This method can be slow on large widget trees but is useful for retheming tk widgets with ttk formatting on theme changes. `Returns a list of widgets`**
> 
> ```python
def recursive_widget_search(node_widget, widget_type_to_find, found_list=[]):
> 	...
> ```
### py_simple_ttk.widgets.WidgetsCore.run_cl<a name="mark26"></a>[^](#mark5)
> **Runs something via command line. `Returns None`**
> 
> ```python
def run_cl(commands: list):
> 	...
> ```
## Core Widgets<a name="mark27"></a>[^](#mark4)

### py_simple_ttk.widgets.MultiWidget.MultiWidgetMixin<a name="mark28"></a>[^](#mark27)
> **An abstract mixin that provides a way to easily instantiate multiple of the same class of a widget and making complicated forms with simple get/set methods.**
> 
> MultiWidgets support a simple get/set system. Calling get without a configuration list returns a dict of subwidget keys mapped to the values of each subwidget's .get value. Passing a list of subwidget keys limits MultiWidgetMixin.get to said subwidgets. Subclassing a multiwidget with one or more instances of one class and then calling multiwidget.add() with different classes after is acceptable assuming the widget supports being added and .get / .set / .enable / .disable / .clear methods.
> ```py
> class MultiWidgetMixin(object):
> 	def __init__(self, widget_type, config: dict):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> ```
### py_simple_ttk.widgets.WidgetsCore.SuperWidgetMixin<a name="mark29"></a>[^](#mark27)
> **Mixin to easily bind many of the common tkinter events.**
> 
> This class serves to add bindings for the majority of common tkinter widget events. The bindings are made in add mode to prevent previous / new bindings from causing unintended side-effects.
> ```py
> class SuperWidgetMixin(object):
> 	def __init__(self, on_mouse_enter=None, on_mouse_leave=None, on_mouse_move=None, on_mouse_wheel=None, on_left_click=None, on_middle_click=None, on_right_click=None, on_configure=None, bind_mouse_scroll=False):
> 		...
> ```
## Tabs<a name="mark30"></a>[^](#mark4)

### py_simple_ttk.widgets.Tabs.Tab<a name="mark31"></a>[^](#mark30)
> **The core Tab class.**
> 
> The notebook object can be any ttk.Notebook, automatically adds itself to its parent notebook with title being the tab label. This class may be instantiated directly and added to or subclassed based on need.
> ```py
> class Tab(Frame):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.LauncherTab<a name="mark32"></a>[^](#mark30)
> **Basic Tab for launching tasks from a list.**
> 
> Performs an action on a list of options. The options argument is formatted as such: `options = {"Button Text 1": val1,"Button Text 2": val2}` Button presses will call `action(val)`
> ```py
> class LauncherTab(Tab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str, options: dict, action: Callable):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.BrowserLauncherTab<a name="mark33"></a>[^](#mark30)
> **LauncherTab that opens a list of URLS/Files**
> 
> Takes a dict of button texts as keys and urls to open as values
> ```py
> class BrowserLauncherTab(LauncherTab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str, options: dict):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.CommandLauncherTab<a name="mark34"></a>[^](#mark30)
> **LauncherTab that runs a list of commands**
> 
> Takes a dict of button texts as keys and command prompt commands to execute as values
> ```py
> class CommandLauncherTab(LauncherTab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str, options: dict):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.ConsoleTab<a name="mark35"></a>[^](#mark30)
> **Basic console tab using a ConsoleWidget**
> 
> ```py
> class ConsoleTab(Tab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.TableTab<a name="mark36"></a>[^](#mark30)
> **Basic Table Tab**
> 
> table_contents is a dictionary whose keys map to lists with the column contents
> ```py
> class TableTab(Tab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str, table_contents: dict, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.Tabs.TreeTableTab<a name="mark37"></a>[^](#mark30)
> **Improved Table Tab**
> 
> table_contents is a dictionary whose keys map to list with the column contents
> ```py
> class TreeTableTab(Tab):
> 	def __init__(self, notebook: tkinter.ttk.Notebook, title: str, table_contents: dict = {}, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Canvas Widgets<a name="mark38"></a>[^](#mark4)

### py_simple_ttk.widgets.ResizableCanvas.ResizableCanvas<a name="mark39"></a>[^](#mark38)
> **Resizeable Canvas**
> 
> Canvas resizes to fit frame on configure event.
> ```py
> class ResizableCanvas(Canvas):
> 	def __init__(self, parent, **kw):
> 		...
> 	def addtag(self, *args):
> 		"""Internal function."""
> 	def addtag_above(self, newtag, tagOrId):
> 		"""Add tag NEWTAG to all items above TAGORID."""
> 	def addtag_all(self, newtag):
> 		"""Add tag NEWTAG to all items."""
> 	def addtag_below(self, newtag, tagOrId):
> 		"""Add tag NEWTAG to all items below TAGORID."""
> 	def addtag_closest(self, newtag, x, y, halo=None, start=None):
> 		"""Add tag NEWTAG to item which is closest to pixel at X, Y.
>         If several match take the top-most.
>         All items closer than HALO are considered overlapping (all are
>         closest). If START is specified the next below this tag is taken."""
> 	def addtag_enclosed(self, newtag, x1, y1, x2, y2):
> 		"""Add tag NEWTAG to all items in the rectangle defined
>         by X1,Y1,X2,Y2."""
> 	def addtag_overlapping(self, newtag, x1, y1, x2, y2):
> 		"""Add tag NEWTAG to all items which overlap the rectangle
>         defined by X1,Y1,X2,Y2."""
> 	def addtag_withtag(self, newtag, tagOrId):
> 		"""Add tag NEWTAG to all items with TAGORID."""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, *args):
> 		"""Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
>         which encloses all items with tags specified as arguments."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def canvasx(self, screenx, gridspacing=None):
> 		"""Return the canvas x coordinate of pixel position SCREENX rounded
>         to nearest multiple of GRIDSPACING units."""
> 	def canvasy(self, screeny, gridspacing=None):
> 		"""Return the canvas y coordinate of pixel position SCREENY rounded
>         to nearest multiple of GRIDSPACING units."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def coords(self, *args):
> 		"""Return a list of coordinates for the item given in ARGS."""
> 	def create_arc(self, *args, **kw):
> 		"""Create arc shaped region with coordinates x1,y1,x2,y2."""
> 	def create_bitmap(self, *args, **kw):
> 		"""Create bitmap with coordinates x1,y1."""
> 	def create_image(self, *args, **kw):
> 		"""Create image item with coordinates x1,y1."""
> 	def create_line(self, *args, **kw):
> 		"""Create line with coordinates x1,y1,...,xn,yn."""
> 	def create_oval(self, *args, **kw):
> 		"""Create oval with coordinates x1,y1,x2,y2."""
> 	def create_polygon(self, *args, **kw):
> 		"""Create polygon with coordinates x1,y1,...,xn,yn."""
> 	def create_rectangle(self, *args, **kw):
> 		"""Create rectangle with coordinates x1,y1,x2,y2."""
> 	def create_round_rectangle(self, x1: float, y1: float, x2: float, y2: float, r: float = 20, fill: str = '', outline: str = '#000000', **kwargs):
> 		"""Draws a rounded rectangle of a given radius on a tk.canvas."""
> 	def create_text(self, *args, **kw):
> 		"""Create text with coordinates x1,y1."""
> 	def create_window(self, *args, **kw):
> 		"""Create window with coordinates x1,y1,x2,y2."""
> 	def dchars(self, *args):
> 		"""Delete characters of text items identified by tag or id in ARGS (possibly
>         several times) from FIRST to LAST character (including)."""
> 	def delete(self, *args):
> 		"""Delete items identified by all tag or ids contained in ARGS."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def dtag(self, *args):
> 		"""Delete tag or id given as last arguments in ARGS from items
>         identified by first argument in ARGS."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def find(self, *args):
> 		"""Internal function."""
> 	def find_above(self, tagOrId):
> 		"""Return items above TAGORID."""
> 	def find_all(self):
> 		"""Return all items."""
> 	def find_below(self, tagOrId):
> 		"""Return all items below TAGORID."""
> 	def find_closest(self, x, y, halo=None, start=None):
> 		"""Return item which is closest to pixel at X, Y.
>         If several match take the top-most.
>         All items closer than HALO are considered overlapping (all are
>         closest). If START is specified the next below this tag is taken."""
> 	def find_enclosed(self, x1, y1, x2, y2):
> 		"""Return all items in rectangle defined
>         by X1,Y1,X2,Y2."""
> 	def find_overlapping(self, x1, y1, x2, y2):
> 		"""Return all items which overlap the rectangle
>         defined by X1,Y1,X2,Y2."""
> 	def find_withtag(self, tagOrId):
> 		"""Return all items with TAGORID."""
> 	def focus(self, *args):
> 		"""Set focus to the first item specified in ARGS."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def gettags(self, *args):
> 		"""Return tags associated with the first item specified in ARGS."""
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def icursor(self, *args):
> 		"""Set cursor at position POS in the item identified by TAGORID.
>         In ARGS TAGORID must be first."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, *args):
> 		"""Return position of cursor as integer in item specified in ARGS."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, *args):
> 		"""Insert TEXT in item TAGORID at position POS. ARGS must
>         be TAGORID POS TEXT."""
> 	def itemcget(self, tagOrId, option):
> 		"""Return the resource value for an OPTION for item TAGORID."""
> 	def itemconfig(self, tagOrId, cnf=None, **kw):
> 		"""Configure resources of an item TAGORID.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method without arguments.
>         """
> 	def itemconfigure(self, tagOrId, cnf=None, **kw):
> 		"""Configure resources of an item TAGORID.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method without arguments.
>         """
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, *args):
> 		"""Raise an item TAGORID given in ARGS
>         (optional above another item)."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, *args):
> 		"""Lower an item TAGORID given in ARGS
>         (optional below another item)."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def move(self, *args):
> 		"""Move an item TAGORID given in ARGS."""
> 	def moveto(self, tagOrId, x='', y=''):
> 		"""Move the items given by TAGORID in the canvas coordinate
>         space so that the first coordinate pair of the bottommost
>         item with tag TAGORID is located at position (X,Y).
>         X and Y may be the empty string, in which case the
>         corresponding coordinate will be unchanged. All items matching
>         TAGORID remain in the same positions relative to each other."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def postscript(self, cnf={}, **kw):
> 		"""Print the contents of the canvas to a postscript
>         file. Valid options: colormap, colormode, file, fontmap,
>         height, pageanchor, pageheight, pagewidth, pagex, pagey,
>         rotate, width, x, y."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def refresh(self):
> 		"""Refresh Canvas"""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scale(self, *args):
> 		"""Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE."""
> 	def scan_dragto(self, x, y, gain=10):
> 		"""Adjust the view of the canvas to GAIN times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x, y):
> 		"""Remember the current X, Y coordinates."""
> 	def select_adjust(self, tagOrId, index):
> 		"""Adjust the end of the selection near the cursor of an item TAGORID to index."""
> 	def select_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def select_from(self, tagOrId, index):
> 		"""Set the fixed end of a selection in item TAGORID to INDEX."""
> 	def select_item(self):
> 		"""Return the item which has the selection."""
> 	def select_to(self, tagOrId, index):
> 		"""Set the variable end of a selection in item TAGORID to INDEX."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def tag_bind(self, tagOrId, sequence=None, func=None, add=None):
> 		"""Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.
> 
>         An additional boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or whether it will
>         replace the previous function. See bind for the return value."""
> 	def tag_lower(self, *args):
> 		"""Lower an item TAGORID given in ARGS
>         (optional below another item)."""
> 	def tag_raise(self, *args):
> 		"""Raise an item TAGORID given in ARGS
>         (optional above another item)."""
> 	def tag_unbind(self, tagOrId, sequence, funcid=None):
> 		"""Unbind for all items with TAGORID for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, *args):
> 		"""Raise an item TAGORID given in ARGS
>         (optional above another item)."""
> 	def type(self, tagOrId):
> 		"""Return the type of the item TAGORID."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> 	def yview(self, *args):
> 		"""Query and change the vertical position of the view."""
> 	def yview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total height of the canvas is off-screen to the top."""
> 	def yview_scroll(self, number, what):
> 		"""Shift the y-view according to NUMBER which is measured in
>         "units" or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.ScrolledCanvas.ScrolledCanvas<a name="mark40"></a>[^](#mark38)
> **Resizeable, Auto-Scrollbarred Canvas**
> 
> Canvas resizes to fit frame on configure event. Canvas has automatic Scrollbars that appear when needed. Canvas background color is based on current theme. Due to how the scrolling is handled the actual Canvas is accessd via `ScrolledCanvas().canvas`.
> ```py
> class ScrolledCanvas(Frame):
> 	def __init__(self, parent, on_mouse_enter=None, on_mouse_leave=None, on_mouse_move=None, on_mouse_wheel=None, on_left_click=None, on_middle_click=None, on_right_click=None, on_configure=None, bind_canvas_scroll=True, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get_adjusted_y_view(self, event):
> 		"""Gets a canvas y-view adjusted based on its scrolled position"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def use_style(self, style):
> 		"""Reformat with a given ttk style. `Returns None`"""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.ScrolledCanvas.TiledCanvas<a name="mark41"></a>[^](#mark38)
> ```py
> class TiledCanvas(ScrolledCanvas):
> 	def __init__(self, *args, tile_width=400, tile_height=100, tile_padx=5, tile_pady=5, tile_color='#424548', text_color='#CCCCCC', border_color='#000000', on_tile_left_click=None, on_tile_middle_click=None, on_tile_right_click=None, override_tile_width=False, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get_adjusted_y_view(self, event):
> 		"""Gets a canvas y-view adjusted based on its scrolled position"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def refresh(self, event=None):
> 		"""Redraw the canvas"""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def use_style(self, style):
> 		"""Reformat with a given ttk style. `Returns None`"""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.ScrolledCanvas.ExampleTile<a name="mark42"></a>[^](#mark38)
> **An example tile for a Scrolled Canvas**
> 
> ```py
> class ExampleTile(object):
> 	def __init__(self, manager, text):
> 		...
> 	def activate(self):
> 		"""Calls the manager to activate the widget."""
> 	def deactivate(self):
> 		"""Calls the manager to deactivate the widget."""
> 	def is_in_range(self, pointer_x, pointer_y):
> 		"""Checks if the mouse pointer is in the tile."""
> 	def set_position(self, x, y):
> 		"""Sets a tiles position for the draw manager's draw method."""
> ```
## Checkbutton Widgets<a name="mark43"></a>[^](#mark4)

### py_simple_ttk.widgets.CheckbuttonWidgets.LabeledCheckbutton<a name="mark44"></a>[^](#mark43)
> **Labeled Checkbutton**
> 
> The "replace_output" keyword argument allows the user to provide a tuple of len 2 to replace the default True/False return values. The "is_child" keyword is used by the multiwidget mixin for label configuration and should probably be left alone unless you are making your own multiwidgets.
> ```py
> class LabeledCheckbutton(Labeler, Checkbutton):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str = '', replace_output: list = None, default: bool = False, is_child: bool = False, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets the Checkbutton to its default value, usually *False* `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Disable Checkbutton. `Returns None`"""
> 	def enable(self):
> 		"""Enable Checkbutton. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Checkbutton value. `Returns a Boolean unless replace_output is set`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def invoke(self):
> 		"""Toggles between the selected and deselected states and
>         invokes the associated command. If the widget is currently
>         selected, sets the option variable to the offvalue option
>         and deselects the widget; otherwise, sets the option variable
>         to the option onvalue.
> 
>         Returns the result of the associated command."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val: bool):
> 		"""Set Checkbutton value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.CheckbuttonWidgets.LabeledMultiCheckbutton<a name="mark45"></a>[^](#mark43)
> **Labeled MultiWidget LabeledCheckbutton.**
> 
> Used when you need multiple, vertically stacked Labeled Checkbuttons
> ```py
> class LabeledMultiCheckbutton(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Combobox Widgets<a name="mark46"></a>[^](#mark4)

### py_simple_ttk.widgets.ComboboxWidgets.LabeledCombobox<a name="mark47"></a>[^](#mark46)
> **Labeled Combobox with the Super Widget mixin**
> 
> Set custom_values keyword to "False" to disable custom user-entered values. Set the "default" keyword to the index of the value to display by default from the "values" keyword.
> ```py
> class LabeledCombobox(Labeler, Combobox, SuperWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, command: Callable = None, default: int = 0, on_keystroke: bool = False, bind_enter: bool = True, bind_escape_clear: bool = True, values: list = (), custom_values: bool = True, labelside: str = 'left', is_child: bool = False, min_width: int = 0, widgetargs={}, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of (x, y, width, height) which describes the
>         bounding box of the character given by index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets Combobox to its default value. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def current(self, newindex=None):
> 		"""If newindex is supplied, sets the combobox value to the
>         element at position newindex in the list of values. Otherwise,
>         returns the index of the current value in the list of values
>         or -1 if the current value does not appear in the list."""
> 	def delete(self, first, last=None):
> 		"""Delete text from FIRST to LAST (not included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Disable Combobox. `Returns None`"""
> 	def enable(self):
> 		"""Enable Combobox. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Combobox value. `Returns a String`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def icursor(self, index):
> 		"""Insert cursor at INDEX."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the
>         empty string if the coordinates are outside the window."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return position of cursor."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, string):
> 		"""Insert STRING at INDEX."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x):
> 		"""Adjust the view of the canvas to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x):
> 		"""Remember the current X, Y coordinates."""
> 	def select_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def select_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def select_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def select_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def select_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def select_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def selection_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def selection_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def selection_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def selection_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def selection_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val: str):
> 		"""Set Combobox value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def validate(self):
> 		"""Force revalidation, independent of the conditions specified
>         by the validate option. Returns False if validation fails, True
>         if it succeeds. Sets or clears the invalid state accordingly."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.ComboboxWidgets.LabeledMultiCombobox<a name="mark48"></a>[^](#mark46)
> **Labeled MultiWidget LabeledCombobox**
> 
> Used when you need mutiple, vertically stacked Labeled Comboboxes
> ```py
> class LabeledMultiCombobox(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Console Widgets<a name="mark49"></a>[^](#mark4)

### py_simple_ttk.widgets.ConsoleWidgets.ConsoleWidget<a name="mark50"></a>[^](#mark49)
> **Set labeltext, even if temporarily at init or the label widget will be ignored**
> 
> Used when you need to drop a console interface into an application. To write to the console call console.print(value). Pass a function as the "command" keyword argument to handle the entry input.
> ```py
> class ConsoleWidget(Labeler, Frame):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str = 'Console: ', entrylabeltext: str = 'Command: ', labelside: str = 'top', button_text: str = 'Run', is_child: bool = False, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def print(self, val, end: str = '\n'):
> 		"""Prints a line to the console with a customizable line ending. `Returns None`"""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Entry Widgets<a name="mark51"></a>[^](#mark4)

### py_simple_ttk.widgets.EntryWidgets.ScrolledEntry<a name="mark52"></a>[^](#mark51)
> **Scrolled ttk.Entry with SuperWidgetMixin**
> 
> This class is here for completeness but most of the time you will want to use the ScrolledText widget. Used when you need a scrollable text entry box.
> ```py
> class ScrolledEntry(Scroller, Entry, SuperWidgetMixin):
> 	def __init__(self, parent, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of (x, y, width, height) which describes the
>         bounding box of the character given by index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def delete(self, first, last=None):
> 		"""Delete text from FIRST to LAST (not included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Return the text."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def icursor(self, index):
> 		"""Insert cursor at INDEX."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the
>         empty string if the coordinates are outside the window."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return position of cursor."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, string):
> 		"""Insert STRING at INDEX."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x):
> 		"""Adjust the view of the canvas to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x):
> 		"""Remember the current X, Y coordinates."""
> 	def select_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def select_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def select_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def select_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def select_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def select_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def selection_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def selection_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def selection_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def selection_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def selection_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def validate(self):
> 		"""Force revalidation, independent of the conditions specified
>         by the validate option. Returns False if validation fails, True
>         if it succeeds. Sets or clears the invalid state accordingly."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.EntryWidgets.LabeledEntry<a name="mark53"></a>[^](#mark51)
> **Labeled ttk.Entry with SuperWidgetMixin**
> 
> Used when you need a Labeled Entry
> ```py
> class LabeledEntry(Labeler, Entry, SuperWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, command: Callable = None, default: str = '', on_keystroke: bool = False, bind_enter: bool = True, bind_escape_clear: bool = True, is_child: bool = False, min_width: int = 0, widgetargs={}, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of (x, y, width, height) which describes the
>         bounding box of the character given by index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Set Entry value to default, empty unless default set. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def delete(self, first, last=None):
> 		"""Delete text from FIRST to LAST (not included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Disable Entry. `Returns None`"""
> 	def enable(self):
> 		"""Enable Entry. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Entry value. `Returns a String`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def icursor(self, index):
> 		"""Insert cursor at INDEX."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the
>         empty string if the coordinates are outside the window."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return position of cursor."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, string):
> 		"""Insert STRING at INDEX."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x):
> 		"""Adjust the view of the canvas to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x):
> 		"""Remember the current X, Y coordinates."""
> 	def select_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def select_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def select_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def select_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def select_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def select_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def selection_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def selection_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def selection_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def selection_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def selection_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Set Entry value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def validate(self):
> 		"""Force revalidation, independent of the conditions specified
>         by the validate option. Returns False if validation fails, True
>         if it succeeds. Sets or clears the invalid state accordingly."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.EntryWidgets.LabeledMultiEntry<a name="mark54"></a>[^](#mark51)
> **Labeled MultiWidget LabeledEntry**
> 
> Used when you need multiple, vertically stacked Labeled Entries
> ```py
> class LabeledMultiEntry(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.EntryWidgets.LabeledButtonEntry<a name="mark55"></a>[^](#mark51)
> **LabeledEntry with a ttk.Button on the right**
> 
> ```py
> class LabeledButtonEntry(LabeledEntry):
> 	def __init__(self, *args, button_text='', **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of (x, y, width, height) which describes the
>         bounding box of the character given by index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Set Entry value to default, empty unless default set. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def delete(self, first, last=None):
> 		"""Delete text from FIRST to LAST (not included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Disable Entry. `Returns None`"""
> 	def enable(self):
> 		"""Enable Entry. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Entry value. `Returns a String`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def icursor(self, index):
> 		"""Insert cursor at INDEX."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the
>         empty string if the coordinates are outside the window."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return position of cursor."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, string):
> 		"""Insert STRING at INDEX."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x):
> 		"""Adjust the view of the canvas to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x):
> 		"""Remember the current X, Y coordinates."""
> 	def select_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def select_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def select_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def select_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def select_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def select_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def selection_adjust(self, index):
> 		"""Adjust the end of the selection near the cursor to INDEX."""
> 	def selection_clear(self):
> 		"""Clear the selection if it is in this widget."""
> 	def selection_from(self, index):
> 		"""Set the fixed end of a selection to INDEX."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_present(self):
> 		"""Return True if there are characters selected in the entry, False
>         otherwise."""
> 	def selection_range(self, start, end):
> 		"""Set the selection from START to END (not included)."""
> 	def selection_to(self, index):
> 		"""Set the variable end of a selection to INDEX."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Set Entry value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def validate(self):
> 		"""Force revalidation, independent of the conditions specified
>         by the validate option. Returns False if validation fails, True
>         if it succeeds. Sets or clears the invalid state accordingly."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.EntryWidgets.LabeledMultiButtonEntry<a name="mark56"></a>[^](#mark51)
> **Labeled MultiWidget LabeledEntry**
> 
> Used when you need multiple, vertically stacked Labeled Button Entries
> ```py
> class LabeledMultiButtonEntry(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.EntryWidgets.PasswordEntry<a name="mark57"></a>[^](#mark51)
> **Username / Password Entry**
> 
> A username/password entry widget with optional password peeking. Set password_char to `''` to show password by default. The provided command will always be called with the tuple `(username_entry.get(), password_entry.get())` as the only argument even if one of the entries is disabled.
> ```py
> class PasswordEntry(Frame):
> 	def __init__(self, *args, instruction_text: str = '', username_text: str = 'Username: ', username_enabled: bool = True, password_text: str = 'Password: ', password_enabled: bool = True, button_text: str = 'Submit', command=<built-in function print>, password_char: str = '*', peek_enabled: bool = True, invert_peek_colors: bool = False, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def on_peek_press(self, event=None):
> 		"""Show the contents of the password entry while it is being pressed"""
> 	def on_peek_release(self, event=None):
> 		"""Rehide the contents of the password entry"""
> 	def on_submit(self, event=None):
> 		"""Calls the provided "command" function with the contents of the entry box. `Returns None`"""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## KeyPad Widgets<a name="mark58"></a>[^](#mark4)

### py_simple_ttk.widgets.KeyPadWidgets.KeypadButton<a name="mark59"></a>[^](#mark58)
> **Base Keypad Button**
> 
> Keypad button that automatically packs itself based on given coordinates. This object is not usually directly instantiated.
> ```py
> class KeypadButton(Button):
> 	def __init__(self, frame, value, coords, callback):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def invoke(self):
> 		"""Invokes the command associated with the button."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.KeyPadWidgets.BaseKeypad<a name="mark60"></a>[^](#mark58)
> **Base Keypad Class**
> 
> Either instantiate directly with a custom layout or subclass with each subclass supplying a custom layout for more keypads. Subclass KeypadButton and supply the class as the "button_type" kwarg for custom buttons.
> ```py
> class BaseKeypad(Frame):
> 	def __init__(self, layout, callback, button_class=<class 'py_simple_ttk.widgets.KeyPadWidgets.KeypadButton'>, *args, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.KeyPadWidgets.DialerKeypad<a name="mark61"></a>[^](#mark58)
> **Phone Dialer Keypad**
> 
> Example 12-button keypad, subclass BaseKeypad and supply a custom layout for more keypads.
> ```py
> class DialerKeypad(BaseKeypad):
> 	def __init__(self, callback, *args, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## ListBox Widgets<a name="mark62"></a>[^](#mark4)

### py_simple_ttk.widgets.ListBoxWidgets.ScrolledListBox<a name="mark63"></a>[^](#mark62)
> **Scrolled Listbox with SuperWidget mixin**
> 
> ```py
> class ScrolledListBox(Scroller, Listbox, SuperWidgetMixin):
> 	def __init__(self, parent, **kw):
> 		...
> 	def activate(self, index):
> 		"""Activate item identified by INDEX."""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
>         which encloses the item identified by the given index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def curselection(self):
> 		"""Return the indices of currently selected item."""
> 	def delete(self, first, last=None):
> 		"""Delete items from FIRST to LAST (included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, first, last=None):
> 		"""Get list of items from FIRST to LAST (included)."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return index of item identified with INDEX."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, *elements):
> 		"""Insert ELEMENTS at INDEX."""
> 	def itemcget(self, index, option):
> 		"""Return the resource value for an ITEM and an OPTION."""
> 	def itemconfig(self, index, cnf=None, **kw):
> 		"""Configure resources of an ITEM.
> 
>         The values for resources are specified as keyword arguments.
>         To get an overview about the allowed keyword arguments
>         call the method without arguments.
>         Valid resource names: background, bg, foreground, fg,
>         selectbackground, selectforeground."""
> 	def itemconfigure(self, index, cnf=None, **kw):
> 		"""Configure resources of an ITEM.
> 
>         The values for resources are specified as keyword arguments.
>         To get an overview about the allowed keyword arguments
>         call the method without arguments.
>         Valid resource names: background, bg, foreground, fg,
>         selectbackground, selectforeground."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def nearest(self, y):
> 		"""Get index of item which is nearest to y coordinate Y."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x, y):
> 		"""Adjust the view of the listbox to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x, y):
> 		"""Remember the current X, Y coordinates."""
> 	def see(self, index):
> 		"""Scroll such that INDEX is visible."""
> 	def select_anchor(self, index):
> 		"""Set the fixed end oft the selection to INDEX."""
> 	def select_clear(self, first, last=None):
> 		"""Clear the selection from FIRST to LAST (included)."""
> 	def select_includes(self, index):
> 		"""Return True if INDEX is part of the selection."""
> 	def select_set(self, first, last=None):
> 		"""Set the selection from FIRST to LAST (included) without
>         changing the currently selected elements."""
> 	def selection_anchor(self, index):
> 		"""Set the fixed end oft the selection to INDEX."""
> 	def selection_clear(self, first, last=None):
> 		"""Clear the selection from FIRST to LAST (included)."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_includes(self, index):
> 		"""Return True if INDEX is part of the selection."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_set(self, first, last=None):
> 		"""Set the selection from FIRST to LAST (included) without
>         changing the currently selected elements."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return the number of elements in the listbox."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> 	def yview(self, *args):
> 		"""Query and change the vertical position of the view."""
> 	def yview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total height of the canvas is off-screen to the top."""
> 	def yview_scroll(self, number, what):
> 		"""Shift the y-view according to NUMBER which is measured in
>         "units" or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.ListBoxWidgets.Table<a name="mark64"></a>[^](#mark62)
> **Listboxes bound to scroll in union. Additional bindings will be needed in order to handle clicking.**
> 
> Tested on Mac/Windows/Linux. In most cases a TreeTable widget will be superior to this.
> ```py
> class Table(Frame):
> 	def __init__(self, *args, min_column_width: int = 100, start_column_width: int = 100, on_selection=None, visible_rows=0, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def build(self, contents: dict):
> 		"""Rebuild the table"""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Clears the table"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Gets the currently selected items from the table. `Returns a List of Strings`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def use_style(self, style: tkinter.ttk.Style):
> 		"""Update to match supplied ttk.Style object. `Returns None`"""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## OptionMenu Widgets<a name="mark65"></a>[^](#mark4)

### py_simple_ttk.widgets.OptionMenuWidgets.LabeledOptionMenu<a name="mark66"></a>[^](#mark65)
> **Labeled OptionMenu widget**
> 
> ```py
> class LabeledOptionMenu(Labeler, OptionMenu):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, options: list, default: int = 0, is_child: bool = False):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets OptionMenu to its default value. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this widget and its associated variable."""
> 	def disable(self):
> 		"""Disable OptionMenu. `Returns None`"""
> 	def enable(self):
> 		"""Enable OptionMenu. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get OptionMenu value. `Returns a String`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Set OptionMenu value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def set_menu(self, default=None, *values):
> 		"""Build a new menu of radiobuttons with *values and optionally
>         a default value."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.OptionMenuWidgets.LabeledMultiOptionMenu<a name="mark67"></a>[^](#mark65)
> **Labeled MultiWidget LabeledOptionMenu**
> 
> ```py
> class LabeledMultiOptionMenu(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## ProgressBar Widgets<a name="mark68"></a>[^](#mark4)

### py_simple_ttk.widgets.ProgressbarWidgets.LabeledProgressbar<a name="mark69"></a>[^](#mark68)
> **Labeled Progressbar**
> 
> ```py
> class LabeledProgressbar(Labeler, Progressbar):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, orient='horizontal', labelside='left', is_child=False, default: float = 0, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets Progresbar progress to its default value `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Enable Progresbar. `Returns None`"""
> 	def enable(self):
> 		"""Disable Progresbar. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Set Progresbar progress. `Returns None`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def link(self, widget):
> 		"""Easily link to other widgets, sets the progressbar var to the passed widget's var. `Returns None`"""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Get Progresbar progress. `Returns a String`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def start(self, interval=None):
> 		"""Begin autoincrement mode: schedules a recurring timer event
>         that calls method step every interval milliseconds.
> 
>         interval defaults to 50 milliseconds (20 steps/second) if omitted."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def step(self, amount=None):
> 		"""Increments the value option by amount.
> 
>         amount defaults to 1.0 if omitted."""
> 	def stop(self):
> 		"""Stop autoincrement mode: cancels any recurring timer event
>         initiated by start."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.ProgressbarWidgets.LabeledMultiProgressbar<a name="mark70"></a>[^](#mark68)
> **Labeled MultiWidget LabeledProgressbar**
> 
> ```py
> class LabeledMultiProgressbar(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top', orient='horizontal'):
> 		...
> 	def add(self, parent: tkinter.ttk.Frame, key: str, args, kwargs, widget_type=None):
> 		"""Overrides MultiWidgetMixin to deal with vertical orientation `Returns None`"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def link(self, config: dict):
> 		"""Link to other widgets with a dict of subwidget keys to link to `Returns None`"""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Radiobutton Widgets<a name="mark71"></a>[^](#mark4)

### py_simple_ttk.widgets.RadiobuttonWidgets.LabeledRadiobutton<a name="mark72"></a>[^](#mark71)
> **Labeled Radiobutton widget**
> 
> ```py
> class LabeledRadiobutton(Labeler, Frame):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, options: list = [], default: int = 0, is_child: bool = False, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets Radiobutton to its default value. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Enable Radiobutton. `Returns None`"""
> 	def enable(self):
> 		"""Disable Radiobutton. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Radiobutton value. `Returns a Bool`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val: bool):
> 		"""Set Radiobutton value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.RadiobuttonWidgets.LabeledMultiRadiobutton<a name="mark73"></a>[^](#mark71)
> **Labeled MultiWidget LabeledRadiobutton**
> 
> ```py
> class LabeledMultiRadiobutton(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top'):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Method for adding different widgets to a multiwidget post-instantiation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Scale Widgets<a name="mark74"></a>[^](#mark4)

### py_simple_ttk.widgets.ScaleWidgets.LabeledScale<a name="mark75"></a>[^](#mark74)
> **Labeled Scale**
> 
> ```py
> class LabeledScale(Labeler, Scale):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, command: Callable = None, default: float = 0, orient: bool = 'horizontal', is_child: bool = False, from_=0, to=100, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Sets Scale to its default value. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Modify or query scale options.
> 
>         Setting a value for any of the "from", "from_" or "to" options
>         generates a <<RangeChanged>> event."""
> 	def coords(self, value=None):
> 		"""Return a tuple (X,Y) of the point along the centerline of the
>         trough that corresponds to VALUE or the current value if None is
>         given."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		"""Enable Scale. `Returns None`"""
> 	def enable(self):
> 		"""Disable Scale. `Returns None`"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self):
> 		"""Get Scale value. `Returns a Float`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Set Scale value. `Returns None`"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
### py_simple_ttk.widgets.ScaleWidgets.LabeledMultiScale<a name="mark76"></a>[^](#mark74)
> **Labeled MultiWidget Labeled Scale**
> 
> ```py
> class LabeledMultiScale(Labeler, Frame, MultiWidgetMixin):
> 	def __init__(self, parent: tkinter.ttk.Frame, labeltext: str, config: dict, is_child: bool = False, labelside='top', orient='horizontal', command=None):
> 		...
> 	def add(self, parent, key, args, kwargs, widget_type=None):
> 		"""Override MultiWidgetMixin for vertical orientation"""
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self, config: list = None):
> 		"""Pass a list of subwidgets to clear or all are set to default"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self, config: list = None):
> 		"""Pass a list of subwidgets to disable or all are disabled"""
> 	def enable(self, config: list = None):
> 		"""Pass a list of subwidgets to enable or all are enabled"""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, config: list = None):
> 		"""Pass a list of widget keys to get a dict of outputs"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, *args, **kw):
> 		"""Forward pack args to container frame."""
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, config: dict):
> 		"""Pass a map of widget keys and their values"""
> 	def set_label_text(self, val: str):
> 		"""Update a Labeled widget's Label text."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Text Widgets<a name="mark77"></a>[^](#mark4)

### py_simple_ttk.widgets.TextWidgets.ScrolledText<a name="mark78"></a>[^](#mark77)
> **Scrolled Textbox**
> 
> Scrolled SuperWidget Text. Configure text by passing the `textkw` argument as a dict formatted like a standard kwarg dict.
> ```py
> class ScrolledText(Scroller, Text, SuperWidgetMixin):
> 	def __init__(self, parent, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, index):
> 		"""Return a tuple of (x,y,width,height) which gives the bounding
>         box of the visible part of the character at the given index."""
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clear(self):
> 		"""Empties the text box. `Returns None`"""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def compare(self, index1, op, index2):
> 		"""Return whether between index INDEX1 and index INDEX2 the
>         relation OP is satisfied. OP is one of <, <=, ==, >=, >, or !=."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def count(self, index1, index2, *args):
> 		"""Counts the number of relevant things between the two indices.
>         If index1 is after index2, the result will be a negative number
>         (and this holds for each of the possible options).
> 
>         The actual items which are counted depends on the options given by
>         args. The result is a list of integers, one for the result of each
>         counting option given. Valid counting options are "chars",
>         "displaychars", "displayindices", "displaylines", "indices",
>         "lines", "xpixels" and "ypixels". There is an additional possible
>         option "update", which if given then all subsequent options ensure
>         that any possible out of date information is recalculated."""
> 	def debug(self, boolean=None):
> 		"""Turn on the internal consistency checks of the B-Tree inside the text
>         widget according to BOOLEAN."""
> 	def delete(self, index1, index2=None):
> 		"""Delete the characters between INDEX1 and INDEX2 (not included)."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		...
> 	def dlineinfo(self, index):
> 		"""Return tuple (x,y,width,height,baseline) giving the bounding box
>         and baseline position of the visible part of the line containing
>         the character at INDEX."""
> 	def dump(self, index1, index2=None, command=None, **kw):
> 		"""Return the contents of the widget between index1 and index2.
> 
>         The type of contents returned in filtered based on the keyword
>         parameters; if 'all', 'image', 'mark', 'tag', 'text', or 'window' are
>         given and true, then the corresponding items are returned. The result
>         is a list of triples of the form (key, value, index). If none of the
>         keywords are true then 'all' is used by default.
> 
>         If the 'command' argument is given, it is called once for each element
>         of the list of triples, with the values of each triple serving as the
>         arguments to the function. In this case the list is not returned."""
> 	def edit(self, *args):
> 		"""Internal method
> 
>         This method controls the undo mechanism and
>         the modified flag. The exact behavior of the
>         command depends on the option argument that
>         follows the edit argument. The following forms
>         of the command are currently supported:
> 
>         edit_modified, edit_redo, edit_reset, edit_separator
>         and edit_undo
> 
>         """
> 	def edit_modified(self, arg=None):
> 		"""Get or Set the modified flag
> 
>         If arg is not specified, returns the modified
>         flag of the widget. The insert, delete, edit undo and
>         edit redo commands or the user can set or clear the
>         modified flag. If boolean is specified, sets the
>         modified flag of the widget to arg.
>         """
> 	def edit_redo(self):
> 		"""Redo the last undone edit
> 
>         When the undo option is true, reapplies the last
>         undone edits provided no other edits were done since
>         then. Generates an error when the redo stack is empty.
>         Does nothing when the undo option is false.
>         """
> 	def edit_reset(self):
> 		"""Clears the undo and redo stacks
>         """
> 	def edit_separator(self):
> 		"""Inserts a separator (boundary) on the undo stack.
> 
>         Does nothing when the undo option is false
>         """
> 	def edit_undo(self):
> 		"""Undoes the last edit action
> 
>         If the undo option is true. An edit action is defined
>         as all the insert and delete commands that are recorded
>         on the undo stack in between two separators. Generates
>         an error when the undo stack is empty. Does nothing
>         when the undo option is false
>         """
> 	def enable(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get(self, start='1.0', end='end'):
> 		"""Returns the contents of the text box with optional start/end kwargs. `Returns a String`"""
> 	def get_cursor(self):
> 		"""Get the current location of the cursor. `Returns None`"""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def image_cget(self, index, option):
> 		"""Return the value of OPTION of an embedded image at INDEX."""
> 	def image_configure(self, index, cnf=None, **kw):
> 		"""Configure an embedded image at INDEX."""
> 	def image_create(self, index, cnf={}, **kw):
> 		"""Create an embedded image at INDEX."""
> 	def image_names(self):
> 		"""Return all names of embedded images in this widget."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def index(self, index):
> 		"""Return the index in the form line.char for INDEX."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def insert(self, index, chars, *args):
> 		"""Insert CHARS before the characters at INDEX. An additional
>         tag can be given in ARGS. Additional CHARS and tags can follow in ARGS."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def mark_gravity(self, markName, direction=None):
> 		"""Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
>         Return the current value if None is given for DIRECTION."""
> 	def mark_names(self):
> 		"""Return all mark names."""
> 	def mark_next(self, index):
> 		"""Return the name of the next mark after INDEX."""
> 	def mark_previous(self, index):
> 		"""Return the name of the previous mark before INDEX."""
> 	def mark_set(self, markName, index):
> 		"""Set mark MARKNAME before the character at INDEX."""
> 	def mark_unset(self, *markNames):
> 		"""Delete all marks in MARKNAMES."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def peer_create(self, newPathName, cnf={}, **kw):
> 		"""Creates a peer text widget with the given newPathName, and any
>         optional standard configuration options. By default the peer will
>         have the same start and end line as the parent widget, but
>         these can be overridden with the standard configuration options."""
> 	def peer_names(self):
> 		"""Returns a list of peers of this widget (this does not include
>         the widget itself)."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def replace(self, index1, index2, chars, *args):
> 		"""Replaces the range of characters between index1 and index2 with
>         the given characters and tags specified by args.
> 
>         See the method insert for some more information about args, and the
>         method delete for information about the indices."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def scan_dragto(self, x, y):
> 		"""Adjust the view of the text to 10 times the
>         difference between X and Y and the coordinates given in
>         scan_mark."""
> 	def scan_mark(self, x, y):
> 		"""Remember the current X, Y coordinates."""
> 	def search(self, pattern, index, stopindex=None, forwards=None, backwards=None, exact=None, regexp=None, nocase=None, count=None, elide=None):
> 		"""Search PATTERN beginning from INDEX until STOPINDEX.
>         Return the index of the first character of a match or an
>         empty string."""
> 	def see(self, index):
> 		"""Scroll such that the character at INDEX is visible."""
> 	def select_all(self, event=None):
> 		"""Selects all text. `Returns None`"""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def set(self, val):
> 		"""Sets the text. `Returns a String`"""
> 	def set_cursor(self, col, row):
> 		"""Sets the cursor to a given col / row. `Returns None`"""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def tag_add(self, tagName, index1, *args):
> 		"""Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
>         Additional pairs of indices may follow in ARGS."""
> 	def tag_bind(self, tagName, sequence, func, add=None):
> 		"""Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.
> 
>         An additional boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or whether it will
>         replace the previous function. See bind for the return value."""
> 	def tag_cget(self, tagName, option):
> 		"""Return the value of OPTION for tag TAGNAME."""
> 	def tag_config(self, tagName, cnf=None, **kw):
> 		"""Configure a tag TAGNAME."""
> 	def tag_configure(self, tagName, cnf=None, **kw):
> 		"""Configure a tag TAGNAME."""
> 	def tag_delete(self, *tagNames):
> 		"""Delete all tags in TAGNAMES."""
> 	def tag_lower(self, tagName, belowThis=None):
> 		"""Change the priority of tag TAGNAME such that it is lower
>         than the priority of BELOWTHIS."""
> 	def tag_names(self, index=None):
> 		"""Return a list of all tag names."""
> 	def tag_nextrange(self, tagName, index1, index2=None):
> 		"""Return a list of start and end index for the first sequence of
>         characters between INDEX1 and INDEX2 which all have tag TAGNAME.
>         The text is searched forward from INDEX1."""
> 	def tag_prevrange(self, tagName, index1, index2=None):
> 		"""Return a list of start and end index for the first sequence of
>         characters between INDEX1 and INDEX2 which all have tag TAGNAME.
>         The text is searched backwards from INDEX1."""
> 	def tag_raise(self, tagName, aboveThis=None):
> 		"""Change the priority of tag TAGNAME such that it is higher
>         than the priority of ABOVETHIS."""
> 	def tag_ranges(self, tagName):
> 		"""Return a list of ranges of text which have tag TAGNAME."""
> 	def tag_remove(self, tagName, index1, index2=None):
> 		"""Remove tag TAGNAME from all characters between INDEX1 and INDEX2."""
> 	def tag_unbind(self, tagName, sequence, funcid=None):
> 		"""Unbind for all characters with TAGNAME for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def window_cget(self, index, option):
> 		"""Return the value of OPTION of an embedded window at INDEX."""
> 	def window_config(self, index, cnf=None, **kw):
> 		"""Configure an embedded window at INDEX."""
> 	def window_configure(self, index, cnf=None, **kw):
> 		"""Configure an embedded window at INDEX."""
> 	def window_create(self, index, cnf={}, **kw):
> 		"""Create a window at INDEX."""
> 	def window_names(self):
> 		"""Return all names of embedded windows in this widget."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def xview(self, *args):
> 		"""Query and change the horizontal position of the view."""
> 	def xview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total width of the canvas is off-screen to the left."""
> 	def xview_scroll(self, number, what):
> 		"""Shift the x-view according to NUMBER which is measured in "units"
>         or "pages" (WHAT)."""
> 	def yview(self, *args):
> 		"""Query and change the vertical position of the view."""
> 	def yview_moveto(self, fraction):
> 		"""Adjusts the view in the window so that FRACTION of the
>         total height of the canvas is off-screen to the top."""
> 	def yview_pickplace(self, *what):
> 		"""Obsolete function, use see."""
> 	def yview_scroll(self, number, what):
> 		"""Shift the y-view according to NUMBER which is measured in
>         "units" or "pages" (WHAT)."""
> ```
### py_simple_ttk.widgets.TextWidgets.CopyBox<a name="mark79"></a>[^](#mark77)
> **Scrolled Text with "Copy tp Clipboard" Button**
> 
> A widget with a scrolled textbox and button that copies the textbox contents to the user's clipboard. Useful for form output, etc.
> ```py
> class CopyBox(Frame):
> 	def __init__(self, parent: tkinter.ttk.Frame, **kw):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def disable(self):
> 		...
> 	def enable(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Toplevel Widgets<a name="mark80"></a>[^](#mark4)

### py_simple_ttk.widgets.ToplevelWidgets.FocusedToplevel<a name="mark81"></a>[^](#mark80)
> **Base Focused Toplevel Class**
> 
> Window that takes focus and center's itself on the current window. Used as a base class for other windows.
> ```py
> class FocusedToplevel(Toplevel):
> 	def __init__(self, *args, title=None, window=None, on_close=None, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
### py_simple_ttk.widgets.ToplevelWidgets.NoticeWindow<a name="mark82"></a>[^](#mark80)
> **Provides the user with a notice.**
> 
> `button_action` can call a function to help with determining acceptance vs. the user hitting the exit button.
> ```py
> class NoticeWindow(FocusedToplevel):
> 	def __init__(self, *args, text=None, button_text='Continue', button_action=None, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
### py_simple_ttk.widgets.ToplevelWidgets.YesNoCancelWindow<a name="mark83"></a>[^](#mark80)
> **Provides the user with a yes/no/cancel option.**
> 
> `no_destroy` can be set to `True` to allow the window to remain open after a selection is made.
> ```py
> class YesNoCancelWindow(FocusedToplevel):
> 	def __init__(self, *args, text: str = None, yes_enabled: bool = True, on_yes=None, yes_text: str = 'Yes', no_enabled: bool = True, on_no=None, no_text: str = 'No', cancel_enabled: bool = True, on_cancel=None, cancel_text: str = 'Cancel', no_destroy: bool = False, focus='', **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
### py_simple_ttk.widgets.ToplevelWidgets.PromptWindow<a name="mark84"></a>[^](#mark80)
> **Prompts the user for a text input**
> 
> `no_destroy` can be set to `True` to allow the window to remain open after a selection is made, useful for informing the user a string input was invalid via setting label_var. If the select_type kwarg is set to true the user will be prompted to select a data type (int / string) to return.
> ```py
> class PromptWindow(FocusedToplevel):
> 	def __init__(self, *args, text: str = 'Enter Text:', on_yes=None, yes_text: str = 'Continue', on_cancel=None, cancel_text: str = 'Cancel', bind_enter: bool = True, no_destroy: bool = False, select_type: bool = False, focus='', **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
### py_simple_ttk.widgets.ToplevelWidgets.PasswordWindow<a name="mark85"></a>[^](#mark80)
> **Password Entry window.**
> 
> Demo Password Entry Window, you will want to copy the source for this widget and rewrite it.
> ```py
> class PasswordWindow(FocusedToplevel):
> 	def __init__(self, window=None, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
### py_simple_ttk.widgets.ToplevelWidgets.ListWindow<a name="mark86"></a>[^](#mark80)
> **Window to select an option from a Scrolled Listbox**
> 
> ```py
> class ListWindow(FocusedToplevel):
> 	def __init__(self, *args, options: list, text: str = 'Select Item:', on_yes=None, yes_text: str = 'Continue', on_cancel=None, cancel_text: str = 'Cancel', no_destroy: bool = False, select_mode: str = 'single', **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		...
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def iconify(self):
> 		"""Display widget as icon."""
> 	def iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def title(self, string=None):
> 		"""Set the title of this widget."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> 	def withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> 	def wm_aspect(self, minNumer=None, minDenom=None, maxNumer=None, maxDenom=None):
> 		"""Instruct the window manager to set the aspect ratio (width/height)
>         of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
>         of the actual values if no argument is given."""
> 	def wm_attributes(self, *args):
> 		"""This subcommand returns or sets platform specific attributes
> 
>         The first form returns a list of the platform specific flags and
>         their values. The second form returns the value for the specific
>         option. The third form sets one or more of the values. The values
>         are as follows:
> 
>         On Windows, -disabled gets or sets whether the window is in a
>         disabled state. -toolwindow gets or sets the style of the window
>         to toolwindow (as defined in the MSDN). -topmost gets or sets
>         whether this is a topmost window (displays above all other
>         windows).
> 
>         On Macintosh, XXXXX
> 
>         On Unix, there are currently no special attribute values.
>         """
> 	def wm_client(self, name=None):
> 		"""Store NAME in WM_CLIENT_MACHINE property of this widget. Return
>         current value."""
> 	def wm_colormapwindows(self, *wlist):
> 		"""Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
>         of this widget. This list contains windows whose colormaps differ from their
>         parents. Return current list of widgets if WLIST is empty."""
> 	def wm_command(self, value=None):
> 		"""Store VALUE in WM_COMMAND property. It is the command
>         which shall be used to invoke the application. Return current
>         command if VALUE is None."""
> 	def wm_deiconify(self):
> 		"""Deiconify this widget. If it was never mapped it will not be mapped.
>         On Windows it will raise this widget and give it the focus."""
> 	def wm_focusmodel(self, model=None):
> 		"""Set focus model to MODEL. "active" means that this widget will claim
>         the focus itself, "passive" means that the window manager shall give
>         the focus. Return current focus model if MODEL is None."""
> 	def wm_forget(self, window):
> 		"""The window will be unmapped from the screen and will no longer
>         be managed by wm. toplevel windows will be treated like frame
>         windows once they are no longer managed by wm, however, the menu
>         option configuration will be remembered and the menus will return
>         once the widget is managed again."""
> 	def wm_frame(self):
> 		"""Return identifier for decorative frame of this widget if present."""
> 	def wm_geometry(self, newGeometry=None):
> 		"""Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
>         current value if None is given."""
> 	def wm_grid(self, baseWidth=None, baseHeight=None, widthInc=None, heightInc=None):
> 		"""Instruct the window manager that this widget shall only be
>         resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
>         height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
>         number of grid units requested in Tk_GeometryRequest."""
> 	def wm_group(self, pathName=None):
> 		"""Set the group leader widgets for related widgets to PATHNAME. Return
>         the group leader of this widget if None is given."""
> 	def wm_iconbitmap(self, bitmap=None, default=None):
> 		"""Set bitmap for the iconified widget to BITMAP. Return
>         the bitmap if None is given.
> 
>         Under Windows, the DEFAULT parameter can be used to set the icon
>         for the widget and any descendants that don't have an icon set
>         explicitly.  DEFAULT can be the relative path to a .ico file
>         (example: root.iconbitmap(default='myicon.ico') ).  See Tk
>         documentation for more information."""
> 	def wm_iconify(self):
> 		"""Display widget as icon."""
> 	def wm_iconmask(self, bitmap=None):
> 		"""Set mask for the icon bitmap of this widget. Return the
>         mask if None is given."""
> 	def wm_iconname(self, newName=None):
> 		"""Set the name of the icon for this widget. Return the name if
>         None is given."""
> 	def wm_iconphoto(self, default=False, *args):
> 		"""Sets the titlebar icon for this window based on the named photo
>         images passed through args. If default is True, this is applied to
>         all future created toplevels as well.
> 
>         The data in the images is taken as a snapshot at the time of
>         invocation. If the images are later changed, this is not reflected
>         to the titlebar icons. Multiple images are accepted to allow
>         different images sizes to be provided. The window manager may scale
>         provided icons to an appropriate size.
> 
>         On Windows, the images are packed into a Windows icon structure.
>         This will override an icon specified to wm_iconbitmap, and vice
>         versa.
> 
>         On X, the images are arranged into the _NET_WM_ICON X property,
>         which most modern window managers support. An icon specified by
>         wm_iconbitmap may exist simultaneously.
> 
>         On Macintosh, this currently does nothing."""
> 	def wm_iconposition(self, x=None, y=None):
> 		"""Set the position of the icon of this widget to X and Y. Return
>         a tuple of the current values of X and X if None is given."""
> 	def wm_iconwindow(self, pathName=None):
> 		"""Set widget PATHNAME to be displayed instead of icon. Return the current
>         value if None is given."""
> 	def wm_manage(self, widget):
> 		"""The widget specified will become a stand alone top-level window.
>         The window will be decorated with the window managers title bar,
>         etc."""
> 	def wm_maxsize(self, width=None, height=None):
> 		"""Set max WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_minsize(self, width=None, height=None):
> 		"""Set min WIDTH and HEIGHT for this widget. If the window is gridded
>         the values are given in grid units. Return the current values if None
>         is given."""
> 	def wm_overrideredirect(self, boolean=None):
> 		"""Instruct the window manager to ignore this widget
>         if BOOLEAN is given with 1. Return the current value if None
>         is given."""
> 	def wm_positionfrom(self, who=None):
> 		"""Instruct the window manager that the position of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_protocol(self, name=None, func=None):
> 		"""Bind function FUNC to command NAME for this widget.
>         Return the function bound to NAME if None is given. NAME could be
>         e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
> 	def wm_resizable(self, width=None, height=None):
> 		"""Instruct the window manager whether this width can be resized
>         in WIDTH or HEIGHT. Both values are boolean values."""
> 	def wm_sizefrom(self, who=None):
> 		"""Instruct the window manager that the size of this widget shall
>         be defined by the user if WHO is "user", and by its own policy if WHO is
>         "program"."""
> 	def wm_state(self, newstate=None):
> 		"""Query or set the state of this widget as one of normal, icon,
>         iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
> 	def wm_title(self, string=None):
> 		"""Set the title of this widget."""
> 	def wm_transient(self, master=None):
> 		"""Instruct the window manager that this widget is transient
>         with regard to widget MASTER."""
> 	def wm_withdraw(self):
> 		"""Withdraw this widget from the screen such that it is unmapped
>         and forgotten by the window manager. Re-draw it with wm_deiconify."""
> ```
## Misc Widgets<a name="mark87"></a>[^](#mark4)

### py_simple_ttk.widgets.ToolTip.ToolTip<a name="mark88"></a>[^](#mark87)
> **Easy ToolTip**
> 
> Easily show theme-friendly tooltip. Currently only left and right align are supported.
> ```py
> class ToolTip(ToolTipBase):
> 	def __init__(self, tipwidget, text: str, align='left'):
> 		...
> ```
### py_simple_ttk.widgets.SizegripWidgets.EasySizegrip<a name="mark89"></a>[^](#mark87)
> **Sizegrip widget with bindings**
> 
> Automatically packs self and binds mouse presses for systems that don't bind automatically.
> ```py
> class EasySizegrip(Sizegrip):
> 	def __init__(self, *args, **kwargs):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
# SuperLib.utils<a name="mark90"></a>[^](#mark0)

## Utils<a name="mark91"></a>[^](#mark90)

### py_simple_ttk.utils.utils.check_if_module_installed<a name="mark92"></a>[^](#mark91)
> **Indicates if a packages is installed. `Returns a Boolean`**
> 
> ```python
def check_if_module_installed(package):
> 	...
> ```
### py_simple_ttk.utils.utils.check_string_contains<a name="mark93"></a>[^](#mark91)
> **Returns `(True, char_index)` if any character from the list exists in the string otherwise returns `(False, None)`**
> 
> ```python
def check_string_contains(string: str, contains_list: tuple):
> 	...
> ```
### py_simple_ttk.utils.utils.dummy_function<a name="mark94"></a>[^](#mark91)
> **Dummy function that nicely prints out any passed args and kwargs. `Returns None`**
> 
> ```python
def dummy_function(*args, **kwargs):
> 	...
> ```
### py_simple_ttk.utils.utils.get_friendly_time<a name="mark95"></a>[^](#mark91)
> **Gets a time string in one of several modes. Modes: `all, time, date, nice_date`. `Returns a String`**
> 
> ```python
def get_friendly_time(timestamp, mode='all'):
> 	...
> ```
### py_simple_ttk.utils.utils.get_installed_packages<a name="mark96"></a>[^](#mark91)
> **Get an alphabetized list of available packages. `Returns a List`**
> 
> ```python
def get_installed_packages():
> 	...
> ```
### py_simple_ttk.utils.utils.get_unix_timestamp<a name="mark97"></a>[^](#mark91)
> **Get a unix timestamp. `Returns a Float`**
> 
> ```python
def get_unix_timestamp():
> 	...
> ```
### py_simple_ttk.utils.utils.get_unix_timestring<a name="mark98"></a>[^](#mark91)
> **Get a unix timestring. `Returns a String`**
> 
> ```python
def get_unix_timestring():
> 	...
> ```
### py_simple_ttk.utils.utils.get_user_home_folder<a name="mark99"></a>[^](#mark91)
> **Cross-platform function to get a user's home folder**
> 
> ```python
def get_user_home_folder():
> 	...
> ```
### py_simple_ttk.utils.utils.open_folder_in_explorer<a name="mark100"></a>[^](#mark91)
> **Cross-platform way to open a folder in the default file manager for a system**
> 
> ```python
def open_folder_in_explorer(path):
> 	...
> ```
### py_simple_ttk.utils.utils.sort_dict_by_keys<a name="mark101"></a>[^](#mark91)
> **Sorts a dictionary by its keys**
> 
> ```python
def sort_dict_by_keys(source: dict, reverse: bool = False):
> 	...
> ```
### py_simple_ttk.utils.utils.timer_decorator<a name="mark102"></a>[^](#mark91)
> **Decorator to add timing to a function**
> 
> ```python
def timer_decorator(proc):
> 	...
> ```
## File Generators<a name="mark103"></a>[^](#mark90)

### py_simple_ttk.utils.HTML_Generator.HTML_Generator<a name="mark104"></a>[^](#mark103)
> ```py
> class HTML_Generator(object):
> 	def __init__(self, indent='\t'):
> 		...
> 	def add_body_line(self, text=''):
> 		...
> 	def add_bold(self, text=''):
> 		...
> 	def add_center(self, text=''):
> 		...
> 	def add_comment(self, text):
> 		...
> 	def add_div(self, text=''):
> 		...
> 	def add_divider(self):
> 		...
> 	def add_list(self, items=[], ordered=False):
> 		...
> 	def add_list_item(self, item: str):
> 		...
> 	def add_paragraph(self, text=''):
> 		...
> 	def assemble(self):
> 		...
> 	def end_bold(self):
> 		...
> 	def end_center(self):
> 		...
> 	def end_div(self):
> 		...
> 	def end_list(self, ordered=False):
> 		...
> 	def end_paragraph(self):
> 		...
> 	def get_indent(self, offset=0):
> 		...
> 	def save(self, path):
> 		...
> 	def start_bold(self, text=''):
> 		...
> 	def start_center(self, text=''):
> 		...
> 	def start_div(self, text=''):
> 		...
> 	def start_list(self, items=[], ordered=False):
> 		...
> 	def start_paragraph(self, text=''):
> 		...
> ```
### py_simple_ttk.utils.TXT_Generator.TXT_Generator<a name="mark105"></a>[^](#mark103)
> ```py
> class TXT_Generator(object):
> 	def __init__(self, ):
> 		...
> 	def add_body_line(self, text=''):
> 		...
> 	def add_divider(self):
> 		...
> 	def assemble(self):
> 		...
> 	def save(self, path):
> 		...
> ```
### py_simple_ttk.utils.MD_Generator.MD_Generator<a name="mark106"></a>[^](#mark103)
> ```py
> class MD_Generator(object):
> 	def __init__(self, title=None, footnote_title='Notes:', footnote_heading_level=2, numbered_toc=False):
> 		...
> 	def add_blockquote(self, text, end='\n\n'):
> 		...
> 	def add_bold(self, text, end='\n\n'):
> 		...
> 	def add_bold_italic(self, text, end='\n'):
> 		...
> 	def add_break(self):
> 		...
> 	def add_code_block(self, text, lang='', end='\n'):
> 		...
> 	def add_heading_1(self, text, **kwargs):
> 		...
> 	def add_heading_2(self, text, **kwargs):
> 		...
> 	def add_heading_3(self, text, **kwargs):
> 		...
> 	def add_heading_4(self, text, **kwargs):
> 		...
> 	def add_heading_5(self, text, **kwargs):
> 		...
> 	def add_heading_6(self, text, **kwargs):
> 		...
> 	def add_horizontal_rule(self):
> 		...
> 	def add_italic(self, text, end='\n'):
> 		...
> 	def add_link(self, link, text=None, tooltip=None):
> 		...
> 	def add_multi_blockquote(self, texts):
> 		...
> 	def add_ordered_list(self, texts, indent=0):
> 		...
> 	def add_paragraph(self, text, end='\n\n'):
> 		...
> 	def add_to_ordered_list(self, index, text, indent=0):
> 		...
> 	def add_to_unordered_list(self, text, indent=0):
> 		...
> 	def add_toc(self, title, end='\n\n'):
> 		...
> 	def add_unordered_list(self, texts, indent=0):
> 		...
> 	def assemble(self):
> 		...
> 	def decrease_toc_depth(self):
> 		...
> 	def get_prefix(self):
> 		...
> 	def increase_toc_depth(self):
> 		...
> 	def insert_footnote(self, text):
> 		...
> 	def save(self, path):
> 		...
> 	def set_slogan(self, slogan):
> 		...
> ```
## History Mixin<a name="mark107"></a>[^](#mark90)

### py_simple_ttk.utils.History.HistoryMixin<a name="mark108"></a>[^](#mark107)
> **Abstract mixin to add history-tracking to an application**
> 
> This object is meant to be used as a mixin rather than instantiated directly most of the time.
> ```py
> class HistoryMixin(object):
> 	def __init__(self, data):
> 		...
> 	def add_history(self, data):
> 		...
> 	def clear_history(self, data):
> 		...
> 	def get_history_uid(self):
> 		...
> 	def redo(self):
> 		...
> 	def undo(self):
> 		...
> ```
## Color Functions<a name="mark109"></a>[^](#mark90)

### py_simple_ttk.utils.color.reduce<a name="mark110"></a>[^](#mark109)
> **Limits a val to a range of 0 to 255**
> 
> ```python
def reduce(in_value: int, maxval: int = 255):
> 	...
> ```
### py_simple_ttk.utils.color.rgb_to_hex<a name="mark111"></a>[^](#mark109)
> **Converts an rgb tuple to hex**
> 
> ```python
def rgb_to_hex(rgb: tuple):
> 	...
> ```
### py_simple_ttk.utils.color.rgba_to_hex<a name="mark112"></a>[^](#mark109)
> **Converts an rgba tuple to rgba hex**
> 
> ```python
def rgba_to_hex(rgba: tuple):
> 	...
> ```
### py_simple_ttk.utils.color.hex_to_rgb<a name="mark113"></a>[^](#mark109)
> **Converts hex to rgb tuple**
> 
> ```python
def hex_to_rgb(hex: str):
> 	...
> ```
### py_simple_ttk.utils.color.hex_to_rgba<a name="mark114"></a>[^](#mark109)
> **Tries to convert rgba hex to rgba, on failure converts rgb hex to rgb and sets a full opacity**
> 
> ```python
def hex_to_rgba(hex: str):
> 	...
> ```
### py_simple_ttk.utils.color.get_gradient<a name="mark115"></a>[^](#mark109)
> **Generates a gradient with a given number of steps**
> 
> ```python
def get_gradient(steps: int):
> 	...
> ```
### py_simple_ttk.utils.color.rgb_to_scalar<a name="mark116"></a>[^](#mark109)
> **Converts an rgb itterable to scalar list**
> 
> ```python
def rgb_to_scalar(rgb: tuple):
> 	...
> ```
### py_simple_ttk.utils.color.scalar_to_rgb<a name="mark117"></a>[^](#mark109)
> **Converts rgb scalar to rgb list**
> 
> ```python
def scalar_to_rgb(rgb: tuple):
> 	...
> ```
### py_simple_ttk.utils.color.linear_gradient<a name="mark118"></a>[^](#mark109)
> **Generates a linear gradient between two colors, accepts html hex or rgb formats**
> 
> ```python
def linear_gradient(start_hex: str = '#000000', finish_hex: str = '#FFFFFF', n: int = 10):
> 	...
> ```
### py_simple_ttk.utils.color.get_rainbow<a name="mark119"></a>[^](#mark109)
> **Generates a rainbow with a given number of steps. Steps must be divisible by 4)**
> 
> ```python
def get_rainbow(steps: int):
> 	...
> ```
# SuperLib.mega_widgets<a name="mark120"></a>[^](#mark0)

## Notes MegaWidget<a name="mark121"></a>[^](#mark120)

### py_simple_ttk.mega_widgets.notes.NotesTab<a name="mark122"></a>[^](#mark121)
> ```py
> class NotesTab(Tab):
> 	def __init__(self, notebook, app):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def copy_note(self, note):
> 		...
> 	def delete_note(self, note):
> 		...
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def export_note_html(self, note):
> 		...
> 	def export_note_json(self, note):
> 		...
> 	def export_note_markdown(self, note):
> 		...
> 	def export_note_text(self, note):
> 		...
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def load_notes(self):
> 		...
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def make_new_note(self, title):
> 		...
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def new_note(self, event=None):
> 		...
> 	def on_toplevel_destroy(self, *args):
> 		"""Function for toplevels to call on no / cancel"""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def reload_notes(self):
> 		...
> 	def rename_note(self, note):
> 		...
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def start_new_note(self, title=None):
> 		...
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Conversation MegaWidget<a name="mark123"></a>[^](#mark120)

### py_simple_ttk.mega_widgets.chat.ConversationsTab<a name="mark124"></a>[^](#mark123)
> ```py
> class ConversationsTab(Tab):
> 	def __init__(self, notebook, app):
> 		...
> 	def after(self, ms, func=None, *args):
> 		"""Call function once after given time.
> 
>         MS specifies the time in milliseconds. FUNC gives the
>         function which shall be called. Additional parameters
>         are given as parameters to the function call.  Return
>         identifier to cancel scheduling with after_cancel."""
> 	def after_cancel(self, id):
> 		"""Cancel scheduling of function identified with ID.
> 
>         Identifier returned by after or after_idle must be
>         given as first parameter.
>         """
> 	def after_idle(self, func, *args):
> 		"""Call FUNC once if the Tcl main loop has no event to
>         process.
> 
>         Return an identifier to cancel the scheduling with
>         after_cancel."""
> 	def anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def bell(self, displayof=0):
> 		"""Ring a display's bell."""
> 	def bind(self, sequence=None, func=None, add=None):
> 		"""Bind to this widget at event SEQUENCE a call to function FUNC.
> 
>         SEQUENCE is a string of concatenated event
>         patterns. An event pattern is of the form
>         <MODIFIER-MODIFIER-TYPE-DETAIL> where MODIFIER is one
>         of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
>         Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
>         B3, Alt, Button4, B4, Double, Button5, B5 Triple,
>         Mod1, M1. TYPE is one of Activate, Enter, Map,
>         ButtonPress, Button, Expose, Motion, ButtonRelease
>         FocusIn, MouseWheel, Circulate, FocusOut, Property,
>         Colormap, Gravity Reparent, Configure, KeyPress, Key,
>         Unmap, Deactivate, KeyRelease Visibility, Destroy,
>         Leave and DETAIL is the button number for ButtonPress,
>         ButtonRelease and DETAIL is the Keysym for KeyPress and
>         KeyRelease. Examples are
>         <Control-Button-1> for pressing Control and mouse button 1 or
>         <Alt-A> for pressing A and the Alt key (KeyPress can be omitted).
>         An event pattern can also be a virtual event of the form
>         <<AString>> where AString can be arbitrary. This
>         event can be generated by event_generate.
>         If events are concatenated they must appear shortly
>         after each other.
> 
>         FUNC will be called if the event sequence occurs with an
>         instance of Event as argument. If the return value of FUNC is
>         "break" no further bound function is invoked.
> 
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function.
> 
>         Bind will return an identifier to allow deletion of the bound function with
>         unbind without memory leak.
> 
>         If FUNC or SEQUENCE is omitted the bound function or list
>         of bound events are returned."""
> 	def bind_all(self, sequence=None, func=None, add=None):
> 		"""Bind to all widgets at an event SEQUENCE a call to function FUNC.
>         An additional boolean parameter ADD specifies whether FUNC will
>         be called additionally to the other bound function or whether
>         it will replace the previous function. See bind for the return value."""
> 	def bind_class(self, className, sequence=None, func=None, add=None):
> 		"""Bind to widgets with bindtag CLASSNAME at event
>         SEQUENCE a call of function FUNC. An additional
>         boolean parameter ADD specifies whether FUNC will be
>         called additionally to the other bound function or
>         whether it will replace the previous function. See bind for
>         the return value."""
> 	def bindtags(self, tagList=None):
> 		"""Set or get the list of bindtags for this widget.
> 
>         With no argument return the list of all bindtags associated with
>         this widget. With a list of strings as argument the bindtags are
>         set to this list. The bindtags determine in which order events are
>         processed (see bind)."""
> 	def cget(self, key):
> 		"""Return the resource value for a KEY given as string."""
> 	def clipboard_append(self, string, **kw):
> 		"""Append STRING to the Tk clipboard.
> 
>         A widget specified at the optional displayof keyword
>         argument specifies the target display. The clipboard
>         can be retrieved with selection_get."""
> 	def clipboard_clear(self, **kw):
> 		"""Clear the data in the Tk clipboard.
> 
>         A widget specified for the optional displayof keyword
>         argument specifies the target display."""
> 	def clipboard_get(self, **kw):
> 		"""Retrieve data from the clipboard on window's display.
> 
>         The window keyword defaults to the root window of the Tkinter
>         application.
> 
>         The type keyword specifies the form in which the data is
>         to be returned and should be an atom name such as STRING
>         or FILE_NAME.  Type defaults to STRING, except on X11, where the default
>         is to try UTF8_STRING and fall back to STRING.
> 
>         This command is equivalent to:
> 
>         selection_get(CLIPBOARD)
>         """
> 	def columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def config(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def configure(self, cnf=None, **kw):
> 		"""Configure resources of a widget.
> 
>         The values for resources are specified as keyword
>         arguments. To get an overview about
>         the allowed keyword arguments call the method keys.
>         """
> 	def copy_conversation(self, conversation):
> 		...
> 	def delete_conversation(self, conversation):
> 		...
> 	def deletecommand(self, name):
> 		"""Internal function.
> 
>         Delete the Tcl command provided in NAME."""
> 	def destroy(self):
> 		"""Destroy this and all descendants widgets."""
> 	def event_add(self, virtual, *sequences):
> 		"""Bind a virtual event VIRTUAL (of the form <<Name>>)
>         to an event SEQUENCE such that the virtual event is triggered
>         whenever SEQUENCE occurs."""
> 	def event_delete(self, virtual, *sequences):
> 		"""Unbind a virtual event VIRTUAL from SEQUENCE."""
> 	def event_generate(self, sequence, **kw):
> 		"""Generate an event SEQUENCE. Additional
>         keyword arguments specify parameter of the event
>         (e.g. x, y, rootx, rooty)."""
> 	def event_info(self, virtual=None):
> 		"""Return a list of all virtual events or the information
>         about the SEQUENCE bound to the virtual event VIRTUAL."""
> 	def export_conversation_html(self, conversation):
> 		...
> 	def export_conversation_json(self, conversation):
> 		...
> 	def export_conversation_markdown(self, conversation):
> 		...
> 	def export_conversation_text(self, conversation):
> 		...
> 	def focus(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def focus_displayof(self):
> 		"""Return the widget which has currently the focus on the
>         display where this widget is located.
> 
>         Return None if the application does not have the focus."""
> 	def focus_force(self):
> 		"""Direct input focus to this widget even if the
>         application does not have the focus. Use with
>         caution!"""
> 	def focus_get(self):
> 		"""Return the widget which has currently the focus in the
>         application.
> 
>         Use focus_displayof to allow working with several
>         displays. Return None if application does not have
>         the focus."""
> 	def focus_lastfor(self):
> 		"""Return the widget which would have the focus if top level
>         for this widget gets the focus from the window manager."""
> 	def focus_set(self):
> 		"""Direct input focus to this widget.
> 
>         If the application currently does not have the focus
>         this widget will get the focus if the application gets
>         the focus through the window manager."""
> 	def forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def get_cached_icon(self, size, color, char):
> 		...
> 	def get_user_icon(self, user):
> 		...
> 	def getboolean(self, s):
> 		"""Return a boolean value for Tcl boolean values true and false given as parameter."""
> 	def getdouble(self, s):
> 		...
> 	def getint(self, s):
> 		...
> 	def getvar(self, name='PY_VAR'):
> 		"""Return value of Tcl variable NAME."""
> 	def grab_current(self):
> 		"""Return widget which has currently the grab in this application
>         or None."""
> 	def grab_release(self):
> 		"""Release grab for this widget if currently set."""
> 	def grab_set(self):
> 		"""Set grab for this widget.
> 
>         A grab directs all events to this and descendant
>         widgets in the application."""
> 	def grab_set_global(self):
> 		"""Set global grab for this widget.
> 
>         A global grab directs all events to this and
>         descendant widgets on the display. Use with caution -
>         other applications do not get events anymore."""
> 	def grab_status(self):
> 		"""Return None, "local" or "global" if this widget has
>         no, a local or a global grab."""
> 	def grid(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_anchor(self, anchor=None):
> 		"""The anchor value controls how to place the grid within the
>         master when no row/column has any weight.
> 
>         The default anchor is nw."""
> 	def grid_bbox(self, column=None, row=None, col2=None, row2=None):
> 		"""Return a tuple of integer coordinates for the bounding
>         box of this widget controlled by the geometry manager grid.
> 
>         If COLUMN, ROW is given the bounding box applies from
>         the cell with row and column 0 to the specified
>         cell. If COL2 and ROW2 are given the bounding box
>         starts at that cell.
> 
>         The returned integers specify the offset of the upper left
>         corner in the master widget and the width and height.
>         """
> 	def grid_columnconfigure(self, index, cnf={}, **kw):
> 		"""Configure column INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the column),
>         weight (how much does additional space propagate to this column)
>         and pad (how much space to let additionally)."""
> 	def grid_configure(self, cnf={}, **kw):
> 		"""Position a widget in the parent widget in a grid. Use as options:
>         column=number - use cell identified with given column (starting with 0)
>         columnspan=number - this widget will span several columns
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         row=number - use cell identified with given row (starting with 0)
>         rowspan=number - this widget will span several rows
>         sticky=NSEW - if cell is larger on which sides will this
>                       widget stick to the cell boundary
>         """
> 	def grid_forget(self):
> 		"""Unmap this widget."""
> 	def grid_info(self):
> 		"""Return information about the options
>         for positioning this widget in a grid."""
> 	def grid_location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def grid_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given, the current setting will be returned.
>         """
> 	def grid_remove(self):
> 		"""Unmap this widget but remember the grid options."""
> 	def grid_rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def grid_size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def grid_slaves(self, row=None, column=None):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def identify(self, x, y):
> 		"""Returns the name of the element at position x, y, or the empty
>         string if the point does not lie within any element.
> 
>         x and y are pixel coordinates relative to the widget."""
> 	def image_names(self):
> 		"""Return a list of all existing image names."""
> 	def image_types(self):
> 		"""Return a list of all available image types (e.g. photo bitmap)."""
> 	def info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def instate(self, statespec, callback=None, *args, **kw):
> 		"""Test the widget's state.
> 
>         If callback is not specified, returns True if the widget state
>         matches statespec and False otherwise. If callback is specified,
>         then it will be invoked with *args, **kw if the widget state
>         matches statespec. statespec is expected to be a sequence."""
> 	def keys(self):
> 		"""Return a list of all resource names of this widget."""
> 	def lift(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def load_conversations(self):
> 		...
> 	def location(self, x, y):
> 		"""Return a tuple of column and row which identify the cell
>         at which the pixel at position X and Y inside the master
>         widget is located."""
> 	def lower(self, belowThis=None):
> 		"""Lower this widget in the stacking order."""
> 	def mainloop(self, n=0):
> 		"""Call the mainloop of Tk."""
> 	def make_new_conversation(self, title):
> 		...
> 	def nametowidget(self, name):
> 		"""Return the Tkinter instance of a widget identified by
>         its Tcl name NAME."""
> 	def new_conversation(self, event=None):
> 		...
> 	def on_toplevel_destroy(self, *args):
> 		"""Function for toplevels to call on no / cancel"""
> 	def option_add(self, pattern, value, priority=None):
> 		"""Set a VALUE (second parameter) for an option
>         PATTERN (first parameter).
> 
>         An optional third parameter gives the numeric priority
>         (defaults to 80)."""
> 	def option_clear(self):
> 		"""Clear the option database.
> 
>         It will be reloaded if option_add is called."""
> 	def option_get(self, name, className):
> 		"""Return the value for an option NAME for this widget
>         with CLASSNAME.
> 
>         Values with higher priority override lower values."""
> 	def option_readfile(self, fileName, priority=None):
> 		"""Read file FILENAME into the option database.
> 
>         An optional second parameter gives the numeric
>         priority."""
> 	def pack(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_configure(self, cnf={}, **kw):
> 		"""Pack a widget in the parent widget. Use as options:
>         after=widget - pack it after you have packed widget
>         anchor=NSEW (or subset) - position widget according to
>                                   given direction
>         before=widget - pack it before you will pack widget
>         expand=bool - expand widget if parent size grows
>         fill=NONE or X or Y or BOTH - fill widget if widget grows
>         in=master - use master to contain this widget
>         in_=master - see 'in' option description
>         ipadx=amount - add internal padding in x direction
>         ipady=amount - add internal padding in y direction
>         padx=amount - add padding in x direction
>         pady=amount - add padding in y direction
>         side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
>         """
> 	def pack_forget(self):
> 		"""Unmap this widget and do not use it for the packing order."""
> 	def pack_info(self):
> 		"""Return information about the packing options
>         for this widget."""
> 	def pack_propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def pack_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def place(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_configure(self, cnf={}, **kw):
> 		"""Place a widget in the parent widget. Use as options:
>         in=master - master relative to which the widget is placed
>         in_=master - see 'in' option description
>         x=amount - locate anchor of this widget at position x of master
>         y=amount - locate anchor of this widget at position y of master
>         relx=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to width of master (1.0 is right edge)
>         rely=amount - locate anchor of this widget between 0.0 and 1.0
>                       relative to height of master (1.0 is bottom edge)
>         anchor=NSEW (or subset) - position anchor according to given direction
>         width=amount - width of this widget in pixel
>         height=amount - height of this widget in pixel
>         relwidth=amount - width of this widget between 0.0 and 1.0
>                           relative to width of master (1.0 is the same width
>                           as the master)
>         relheight=amount - height of this widget between 0.0 and 1.0
>                            relative to height of master (1.0 is the same
>                            height as the master)
>         bordermode="inside" or "outside" - whether to take border width of
>                                            master widget into account
>         """
> 	def place_forget(self):
> 		"""Unmap this widget."""
> 	def place_info(self):
> 		"""Return information about the placing options
>         for this widget."""
> 	def place_slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def propagate(self, flag=['_noarg_']):
> 		"""Set or get the status for propagation of geometry information.
> 
>         A boolean argument specifies whether the geometry information
>         of the slaves will determine the size of this widget. If no argument
>         is given the current setting will be returned.
>         """
> 	def quit(self):
> 		"""Quit the Tcl interpreter. All widgets will be destroyed."""
> 	def register(self, func, subst=None, needcleanup=1):
> 		"""Return a newly created Tcl function. If this
>         function is called, the Python function FUNC will
>         be executed. An optional function SUBST can
>         be given which will be executed before FUNC."""
> 	def reload_conversations(self):
> 		...
> 	def rename_conversation(self, conversation):
> 		...
> 	def rowconfigure(self, index, cnf={}, **kw):
> 		"""Configure row INDEX of a grid.
> 
>         Valid resources are minsize (minimum size of the row),
>         weight (how much does additional space propagate to this row)
>         and pad (how much space to let additionally)."""
> 	def selection_clear(self, **kw):
> 		"""Clear the current X selection."""
> 	def selection_get(self, **kw):
> 		"""Return the contents of the current X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection and defaults to PRIMARY.  A keyword
>         parameter displayof specifies a widget on the display
>         to use. A keyword parameter type specifies the form of data to be
>         fetched, defaulting to STRING except on X11, where UTF8_STRING is tried
>         before STRING."""
> 	def selection_handle(self, command, **kw):
> 		"""Specify a function COMMAND to call if the X
>         selection owned by this widget is queried by another
>         application.
> 
>         This function must return the contents of the
>         selection. The function will be called with the
>         arguments OFFSET and LENGTH which allows the chunking
>         of very long selections. The following keyword
>         parameters can be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def selection_own(self, **kw):
> 		"""Become owner of X selection.
> 
>         A keyword parameter selection specifies the name of
>         the selection (default PRIMARY)."""
> 	def selection_own_get(self, **kw):
> 		"""Return owner of X selection.
> 
>         The following keyword parameter can
>         be provided:
>         selection - name of the selection (default PRIMARY),
>         type - type of the selection (e.g. STRING, FILE_NAME)."""
> 	def send(self, interp, cmd, *args):
> 		"""Send Tcl command CMD to different interpreter INTERP to be executed."""
> 	def setvar(self, name='PY_VAR', value='1'):
> 		"""Set Tcl variable NAME to VALUE."""
> 	def size(self):
> 		"""Return a tuple of the number of column and rows in the grid."""
> 	def slaves(self):
> 		"""Return a list of all slaves of this widget
>         in its packing order."""
> 	def start_new_conversation(self, title=None):
> 		...
> 	def state(self, statespec=None):
> 		"""Modify or inquire widget state.
> 
>         Widget state is returned if statespec is None, otherwise it is
>         set according to the statespec flags and then a new state spec
>         is returned indicating which flags were changed. statespec is
>         expected to be a sequence."""
> 	def tk_bisque(self):
> 		"""Change the color scheme to light brown as used in Tk 3.6 and before."""
> 	def tk_focusFollowsMouse(self):
> 		"""The widget under mouse will get automatically focus. Can not
>         be disabled easily."""
> 	def tk_focusNext(self):
> 		"""Return the next widget in the focus order which follows
>         widget which has currently the focus.
> 
>         The focus order first goes to the next child, then to
>         the children of the child recursively and then to the
>         next sibling which is higher in the stacking order.  A
>         widget is omitted if it has the takefocus resource set
>         to 0."""
> 	def tk_focusPrev(self):
> 		"""Return previous widget in the focus order. See tk_focusNext for details."""
> 	def tk_setPalette(self, *args, **kw):
> 		"""Set a new color scheme for all widget elements.
> 
>         A single color as argument will cause that all colors of Tk
>         widget elements are derived from this.
>         Alternatively several keyword parameters and its associated
>         colors can be given. The following keywords are valid:
>         activeBackground, foreground, selectColor,
>         activeForeground, highlightBackground, selectBackground,
>         background, highlightColor, selectForeground,
>         disabledForeground, insertBackground, troughColor."""
> 	def tk_strictMotif(self, boolean=None):
> 		"""Set Tcl internal variable, whether the look and feel
>         should adhere to Motif.
> 
>         A parameter of 1 means adhere to Motif (e.g. no color
>         change if mouse passes over slider).
>         Returns the set value."""
> 	def tkraise(self, aboveThis=None):
> 		"""Raise this widget in the stacking order."""
> 	def unbind(self, sequence, funcid=None):
> 		"""Unbind for this widget for event SEQUENCE  the
>         function identified with FUNCID."""
> 	def unbind_all(self, sequence):
> 		"""Unbind for all widgets for event SEQUENCE all functions."""
> 	def unbind_class(self, className, sequence):
> 		"""Unbind for all widgets with bindtag CLASSNAME for event SEQUENCE
>         all functions."""
> 	def update(self):
> 		"""Enter event loop until all pending events have been processed by Tcl."""
> 	def update_idletasks(self):
> 		"""Enter event loop until all idle callbacks have been called. This
>         will update the display of windows but not process events caused by
>         the user."""
> 	def wait_variable(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def wait_visibility(self, window=None):
> 		"""Wait until the visibility of a WIDGET changes
>         (e.g. it appears).
> 
>         If no parameter is given self is used."""
> 	def wait_window(self, window=None):
> 		"""Wait until a WIDGET is destroyed.
> 
>         If no parameter is given self is used."""
> 	def waitvar(self, name='PY_VAR'):
> 		"""Wait until the variable is modified.
> 
>         A parameter of type IntVar, StringVar, DoubleVar or
>         BooleanVar must be given."""
> 	def winfo_atom(self, name, displayof=0):
> 		"""Return integer which represents atom NAME."""
> 	def winfo_atomname(self, id, displayof=0):
> 		"""Return name of atom with identifier ID."""
> 	def winfo_cells(self):
> 		"""Return number of cells in the colormap for this widget."""
> 	def winfo_children(self):
> 		"""Return a list of all widgets which are children of this widget."""
> 	def winfo_class(self):
> 		"""Return window class name of this widget."""
> 	def winfo_colormapfull(self):
> 		"""Return True if at the last color request the colormap was full."""
> 	def winfo_containing(self, rootX, rootY, displayof=0):
> 		"""Return the widget which is at the root coordinates ROOTX, ROOTY."""
> 	def winfo_depth(self):
> 		"""Return the number of bits per pixel."""
> 	def winfo_exists(self):
> 		"""Return true if this widget exists."""
> 	def winfo_fpixels(self, number):
> 		"""Return the number of pixels for the given distance NUMBER
>         (e.g. "3c") as float."""
> 	def winfo_geometry(self):
> 		"""Return geometry string for this widget in the form "widthxheight+X+Y"."""
> 	def winfo_height(self):
> 		"""Return height of this widget."""
> 	def winfo_id(self):
> 		"""Return identifier ID for this widget."""
> 	def winfo_interps(self, displayof=0):
> 		"""Return the name of all Tcl interpreters for this display."""
> 	def winfo_ismapped(self):
> 		"""Return true if this widget is mapped."""
> 	def winfo_manager(self):
> 		"""Return the window manager name for this widget."""
> 	def winfo_name(self):
> 		"""Return the name of this widget."""
> 	def winfo_parent(self):
> 		"""Return the name of the parent of this widget."""
> 	def winfo_pathname(self, id, displayof=0):
> 		"""Return the pathname of the widget given by ID."""
> 	def winfo_pixels(self, number):
> 		"""Rounded integer value of winfo_fpixels."""
> 	def winfo_pointerx(self):
> 		"""Return the x coordinate of the pointer on the root window."""
> 	def winfo_pointerxy(self):
> 		"""Return a tuple of x and y coordinates of the pointer on the root window."""
> 	def winfo_pointery(self):
> 		"""Return the y coordinate of the pointer on the root window."""
> 	def winfo_reqheight(self):
> 		"""Return requested height of this widget."""
> 	def winfo_reqwidth(self):
> 		"""Return requested width of this widget."""
> 	def winfo_rgb(self, color):
> 		"""Return a tuple of integer RGB values in range(65536) for color in this widget."""
> 	def winfo_rootx(self):
> 		"""Return x coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_rooty(self):
> 		"""Return y coordinate of upper left corner of this widget on the
>         root window."""
> 	def winfo_screen(self):
> 		"""Return the screen name of this widget."""
> 	def winfo_screencells(self):
> 		"""Return the number of the cells in the colormap of the screen
>         of this widget."""
> 	def winfo_screendepth(self):
> 		"""Return the number of bits per pixel of the root window of the
>         screen of this widget."""
> 	def winfo_screenheight(self):
> 		"""Return the number of pixels of the height of the screen of this widget
>         in pixel."""
> 	def winfo_screenmmheight(self):
> 		"""Return the number of pixels of the height of the screen of
>         this widget in mm."""
> 	def winfo_screenmmwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in mm."""
> 	def winfo_screenvisual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the default
>         colormodel of this screen."""
> 	def winfo_screenwidth(self):
> 		"""Return the number of pixels of the width of the screen of
>         this widget in pixel."""
> 	def winfo_server(self):
> 		"""Return information of the X-Server of the screen of this widget in
>         the form "XmajorRminor vendor vendorVersion"."""
> 	def winfo_toplevel(self):
> 		"""Return the toplevel widget of this widget."""
> 	def winfo_viewable(self):
> 		"""Return true if the widget and all its higher ancestors are mapped."""
> 	def winfo_visual(self):
> 		"""Return one of the strings directcolor, grayscale, pseudocolor,
>         staticcolor, staticgray, or truecolor for the
>         colormodel of this widget."""
> 	def winfo_visualid(self):
> 		"""Return the X identifier for the visual for this widget."""
> 	def winfo_visualsavailable(self, includeids=False):
> 		"""Return a list of all visuals available for the screen
>         of this widget.
> 
>         Each item in the list consists of a visual name (see winfo_visual), a
>         depth and if includeids is true is given also the X identifier."""
> 	def winfo_vrootheight(self):
> 		"""Return the height of the virtual root window associated with this
>         widget in pixels. If there is no virtual root window return the
>         height of the screen."""
> 	def winfo_vrootwidth(self):
> 		"""Return the width of the virtual root window associated with this
>         widget in pixel. If there is no virtual root window return the
>         width of the screen."""
> 	def winfo_vrootx(self):
> 		"""Return the x offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_vrooty(self):
> 		"""Return the y offset of the virtual root relative to the root
>         window of the screen of this widget."""
> 	def winfo_width(self):
> 		"""Return the width of this widget."""
> 	def winfo_x(self):
> 		"""Return the x coordinate of the upper left corner of this widget
>         in the parent."""
> 	def winfo_y(self):
> 		"""Return the y coordinate of the upper left corner of this widget
>         in the parent."""
> ```
## Profile Management<a name="mark125"></a>[^](#mark120)

### py_simple_ttk.utils.ProfilesSystem.ProfilesSystem<a name="mark126"></a>[^](#mark125)
> ```py
> class ProfilesSystem(object):
> 	def __init__(self, select_profile_actions: list = [], refresh_profiles_actions: list = [], profiles_dir: str = 'C:\\Users\\arcti\\github\\SuperTTK\\Profiles', handle_duplicates: bool = True):
> 		...
> 	def add_refresh_profiles_action(self, action):
> 		"""Add an action to the profiles list refresh actions"""
> 	def add_refresh_profiles_actions(self, actions: list):
> 		"""Add a list of actions to the profiles list refresh actions"""
> 	def add_select_profile_action(self, action):
> 		"""Add an action to the profile switch actions"""
> 	def add_select_profile_actions(self, actions: list):
> 		"""Add a list of actions to the profile switch actions"""
> 	def check_if_name_exists_in_profiles(self, name: str, profiles: list = None):
> 		"""Check if a name exists in a list of profiles, if no list is provided uses the list of all profiles. `Returns a Bool`"""
> 	def clear_refresh_profile_actions(self, new: list = []):
> 		"""Clear out the profiles list refresh actions, optionally replacing them with new ones"""
> 	def clear_select_profile_actions(self, new: list = []):
> 		"""Clear out the profile switch actions, optionally replacing them with new ones"""
> 	def create_profile(self, name: str):
> 		"""Creates a profile with a given name. `Raises ValueError` if the profile name already exists. `Returns a UserProfile`"""
> 	def delete_profile(self, profile: py_simple_ttk.utils.ProfilesSystem.UserProfile):
> 		...
> 	def get_last_used_profile(self, profiles: list = None):
> 		"""Returns the most recently accessed profile"""
> 	def get_profile_by_username(self, name: str):
> 		...
> 	def get_profile_names(self):
> 		"""Returns an alphabetically sorted list of profile names"""
> 	def handle_duplicate_profile_names(self, name: str):
> 		"""Makes profile names unique if they have identical names. The most recently accessed profile (according to the file json) keeps its name untouched. `Returns None`"""
> 	def handle_refresh_profiles_actions(self):
> 		"""Handle on-refresh-profiles actions"""
> 	def handle_select_profile_actions(self):
> 		"""Handle on-profile-selection actions"""
> 	def select_profile(self, profile: py_simple_ttk.utils.ProfilesSystem.UserProfile):
> 		"""Change the currently selected profile"""
> 	def select_profile_by_username(self, name: str):
> 		...
> 	def sort_profiles_by_accessed(self, profiles: list = None):
> 		"""Sort a list of profiles by last accessed, if no list is provided returns a sorted list of all profiles in the system. `Returns a List`"""
> ```
### py_simple_ttk.utils.ProfilesSystem.UserProfile<a name="mark127"></a>[^](#mark125)
> **A class to represent a User / User's Preferences**
> 
> Must pass a unique username and a unique identifier for new profile.
> ```py
> class UserProfile(object):
> 	def __init__(self, path, username: str = None, atomic: str = None):
> 		...
> 	def clear_preferences(self, preferences: list = None):
> 		...
> 	def get_preference(self, key: str):
> 		...
> 	def load(self):
> 		...
> 	def save(self):
> 		...
> 	def set_preference(self, key: str, value: str):
> 		...
> 	def set_username(self, name: str):
> 		...
> ```
### py_simple_ttk.utils.ProfilesSystem.get_profiles_folder<a name="mark128"></a>[^](#mark127)
> **Gets the absolute path to the included profiles folder. `Returns a String`**
> 
> ```python
def get_profiles_folder():
> 	...
> ```
### py_simple_ttk.utils.ProfilesSystem.get_profiles_list<a name="mark129"></a>[^](#mark127)
> **Gets a list of profile files at a given path. `Returns a List of Path strings`**
> 
> ```python
def get_profiles_list(path='./Profiles', verbose=False):
> 	...
> ```
# Changelog<a name="mark130"></a>[^](#mark0)

## 0.1.0<a name="mark131"></a>[^](#mark130)

Modulize



Generated with [py_simple_readme](https://github.com/AndrewSpangler/py_simple_readme)